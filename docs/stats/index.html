<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyleida.stats API documentation</title>
<meta name="description" content="The module &#39;pyleida.stats&#39; provides functions
to execute statistical analyses on the dynamical
system theory metrics." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
    <a href="https://sites.google.com/view/psychomark/home">
        <img src="../imgs/psychomark_logo.png" alt="logo" width="150" height="100"/>
    </a>
<h1 class="title"><code>pyleida.stats</code></h1>
</header>
<section id="section-intro">
<p>The module 'pyleida.stats' provides functions
to execute statistical analyses on the dynamical
system theory metrics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The module &#39;pyleida.stats&#39; provides functions
to execute statistical analyses on the dynamical
system theory metrics.&#34;&#34;&#34;

from ._stats import (
    ks_distance,
    _compute_stats,
    scatter_pvalues,
    permtest_ind,
    permtest_rel,
    hedges_g
)

__all__ = [
    &#34;ks_distance&#34;,
    &#34;_compute_stats&#34;,
    &#34;scatter_pvalues&#34;,
    &#34;permtest_ind&#34;,
    &#34;permtest_rel&#34;,
    &#34;hedges_g&#34;
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyleida.stats._compute_stats"><code class="name flex">
<span>def <span class="ident">_compute_stats</span></span>(<span>dynamics_data, paired_tests=False, n_perm=5000, alternative='two-sided', save_results=True, path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the statistical analysis of dwell times and
occupancies for each cluster (i.e., phase-locking state)
of each K partition.</p>
<h2 id="params">Params:</h2>
<p>dynamics_data : dict.
Output of 'compute_dynamics_metrics' function.
Contains the values of a given dynamical systems
theory metric for each K partition.</p>
<p>paired_tests : bool. Default: False
Specify if groups are independent or related/paired,
to run the correct test.</p>
<p>n_perm : int.
Number of permutations.</p>
<p>alternative : str. Default: 'two-sided'.
Specify the hypothesis to test.
Options: 'two-sided','greater','less'. </p>
<p>save_results : bool.
Whether to save results on local folder.</p>
<p>path : str.
Specify the path in which the results will
be saved if 'save_results' was set to True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _compute_stats(dynamics_data,paired_tests=False,n_perm=5_000,alternative=&#39;two-sided&#39;,save_results=True,path=None):
    &#34;&#34;&#34;
    Performs the statistical analysis of dwell times and
    occupancies for each cluster (i.e., phase-locking state)
    of each K partition.

    Params:
    --------
    dynamics_data : dict.
        Output of &#39;compute_dynamics_metrics&#39; function.
        Contains the values of a given dynamical systems
        theory metric for each K partition.

    paired_tests : bool. Default: False
        Specify if groups are independent or related/paired,
        to run the correct test.

    n_perm : int.
        Number of permutations.

    alternative : str. Default: &#39;two-sided&#39;.
        Specify the hypothesis to test.
        Options: &#39;two-sided&#39;,&#39;greater&#39;,&#39;less&#39;. 

    save_results : bool.
        Whether to save results on local folder.

    path : str.
        Specify the path in which the results will
        be saved if &#39;save_results&#39; was set to True.
    &#34;&#34;&#34;
    #validation of input arguments parameters
    alternative_options = [&#39;two-sided&#39;,&#39;greater&#39;,&#39;less&#39;]

    if alternative not in alternative_options:
        raise ValueError(f&#34;Valid &#39;alternative&#39; options are {alternative_options}.&#34;)

    stats_all = {}

    ks = list(dynamics_data[&#39;occupancies&#39;].keys())

    for metric in [&#39;dwell_times&#39;,&#39;occupancies&#39;]:
        stats_all[metric] = {}
        for k in ks:
            data = dynamics_data[metric][k]
            data = data.iloc[:,1:] #drop the column with subject_ids

            conditions = np.unique(data.condition) #get conditions
            N_conditions = conditions.size
            results_stacked = []

            #for each combination of conditions
            for conds in combinations(conditions,2): 
                data_ = data[data.condition.isin(conds)] #keep data from current 2 conditions

                #compute statistics
                if paired_tests:
                    stats_results = permtest_rel(
                        data_,
                        class_column=&#39;condition&#39;,
                        alternative=alternative,
                        n_perm=n_perm
                        )
                else:
                    stats_results = permtest_ind(
                        data_,
                        class_column=&#39;condition&#39;,
                        alternative=alternative,
                        n_perm=n_perm
                        )

                results_stacked.append(stats_results)

            if N_conditions&gt;2:
                metric_results = pd.concat(results_stacked,axis=0).reset_index(drop=True)
            else:
                metric_results = pd.DataFrame(stats_results)

            metric_results.insert(0,&#39;k&#39;,int([i for i in k.replace(&#39;_&#39;,&#39; &#39;).split() if i.isdigit()][0]))
            stats_all[metric][k] = metric_results

            if save_results:
                try:
                    data_path = f&#39;{path}/dynamics_metrics&#39; #path in which the dynamical systems theory metrics for each k were saved.
                    metric_results.to_csv(f&#39;{data_path}/{k}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;,index=False)
                except:
                    print(&#34;Warning: there was a problem when saving the results to local folder.&#34;)
    
    print(&#39;*The statistical analysis has finished.&#39;)
    return stats_all</code></pre>
</details>
</dd>
<dt id="pyleida.stats.hedges_g"><code class="name flex">
<span>def <span class="ident">hedges_g</span></span>(<span>x1, x2, paired=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes Hedges's g (effect size).
To understand the magnitude of the detected intergroup
differences
independently of the sample size, the effect
size is estimated using Hedge's statistic (Hedges, 1981).
The use of this measure is based on its appropriateness
to easure the effect size for the difference between means
and to account for the size of the sample from each group.</p>
<h2 id="params">Params:</h2>
<p>x1 : ndarray with shape (N_samples).
Observations of 1st condition/group.</p>
<p>x2 : ndarray with shape (N_samples).
Observations of 2nd condition/group.</p>
<p>paired : bool.
Whether conditions/groups are paired
or independent.</p>
<h2 id="returns">Returns:</h2>
<p>g : float.
Hedge's effect size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hedges_g(x1,x2,paired=False):
    &#34;&#34;&#34;
    Computes Hedges&#39;s g (effect size).
    To understand the magnitude of the detected intergroup
    differences  independently of the sample size, the effect
    size is estimated using Hedge&#39;s statistic (Hedges, 1981).
    The use of this measure is based on its appropriateness
    to easure the effect size for the difference between means
    and to account for the size of the sample from each group.

    Params:
    -------
    x1 : ndarray with shape (N_samples).
        Observations of 1st condition/group.

    x2 : ndarray with shape (N_samples).
        Observations of 2nd condition/group.

    paired : bool.
        Whether conditions/groups are paired
        or independent.

    Returns:
    --------
    g : float.
        Hedge&#39;s effect size.
    &#34;&#34;&#34;
    #sample sizes
    n1 = x1.size
    n2 = x2.size
    
    #degrees of freedom
    dof = n1+n2-2
    
    #variances
    var1 = np.var(x1)
    var2 = np.var(x2)
    
    #difference in means
    m1 = np.mean(x1)
    m2 = np.mean(x2)
    diff_mean = np.abs(m1-m2)
    
    #pooled standard deviation
    #s1 = np.std(x1)
    #s2 = np.std(x2)
    
    #Hedges&#39;s g
    if not paired:
        s_pooled = np.sqrt(
            (((n1-1)*var1)+((n2-1)*var2))/dof
            )
        g = diff_mean/s_pooled

    else:
        g = diff_mean / np.sqrt((var1+var2) / 2)

    return g</code></pre>
</details>
</dd>
<dt id="pyleida.stats.ks_distance"><code class="name flex">
<span>def <span class="ident">ks_distance</span></span>(<span>txt1, txt2, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the 2-sample Kolmogorov-Smirnov test of
goodness-of-fit (aka distance) between distributions
of two (or groups of) Time x Time matrices. This
technique can be used, e.g., to compare matrices
between groups/conditions or to determine the best
fit between a simulated FC matrix and a real/empirical
FC matrix.</p>
<h2 id="params">Params:</h2>
<p>txt1 : ndarray with shape (N_time_points, N_time_points) or (N_time_points, N_time_points, N_subjects). </p>
<p>txt2 : ndarray with shape (N_time_points, N_time_points) or (N_time_points, N_time_points, N_subjects). </p>
<h2 id="returns">Returns:</h2>
<p>distance : float
Computed distances between matrices.</p>
<p>pval : float
P-value of the statistical test.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ks_distance(txt1,txt2,plot=False):
    &#34;&#34;&#34;
    Compute the 2-sample Kolmogorov-Smirnov test of
    goodness-of-fit (aka distance) between distributions
    of two (or groups of) Time x Time matrices. This
    technique can be used, e.g., to compare matrices
    between groups/conditions or to determine the best
    fit between a simulated FC matrix and a real/empirical
    FC matrix.

    Params:
    -------
    txt1 : ndarray with shape (N_time_points, N_time_points) or (N_time_points, N_time_points, N_subjects). 

    txt2 : ndarray with shape (N_time_points, N_time_points) or (N_time_points, N_time_points, N_subjects). 

    Returns:
    --------
    distance : float
        Computed distances between matrices.

    pval : float
        P-value of the statistical test.
    &#34;&#34;&#34;
    if txt1.ndim&gt;2:
        txt1_,txt2_ = [],[]
        for sub in range(txt1.shape[-1]):
            txt1_.extend(txt1[:,:,sub][np.triu_indices_from(txt1[:,:,sub],k=1)])
            txt2_.extend(txt2[:,:,sub][np.triu_indices_from(txt2[:,:,sub],k=1)])
        txt1_, txt2_ = np.array(txt1_),np.array(txt2_)

    else:
        txt1_ = txt1[np.triu_indices_from(txt1,k=1)]
        txt2_ = txt2[np.triu_indices_from(txt2,k=1)]
    distance,pval = ks_2samp(txt1_,txt2_)

    if plot: 
        plt.figure()
        sns.distplot(txt1_)
        sns.distplot(txt2_)
        plt.tight_layout()
        plt.show()

    return distance, pval</code></pre>
</details>
</dd>
<dt id="pyleida.stats.permtest_ind"><code class="name flex">
<span>def <span class="ident">permtest_ind</span></span>(<span>data, class_column=None, n_perm=5000, alternative='two-sided')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a permutation test on two independent
groups for each variable or feature in 'data',
and additionally computes a Bonferroni-corrected
alpha.</p>
<h2 id="params">Params:</h2>
<p>data : pd.dataframe.
Contains the dataset with the metric values
we want to compare.
E.g.: the fractional occupancies.</p>
<p>class_colum : str.
Specify the name of the column that contains
the class/group/session/condition information.</p>
<p>n_perm : int. Default 5000.
Select the number of permutations to perform.</p>
<p>alternative : str. Default='two-sided'.
Select the test type. Options are 'less', 'two-sided',
'greater'.</p>
<h2 id="returns">Returns:</h2>
<p>results : pd.dataframe.
Contains the results of the permutation tests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permtest_ind(data,class_column=None,n_perm=5_000,alternative=&#39;two-sided&#39;):
    &#34;&#34;&#34;
    Compute a permutation test on two independent
    groups for each variable or feature in &#39;data&#39;,
    and additionally computes a Bonferroni-corrected
    alpha.

    Params:
    -------
    data : pd.dataframe.
        Contains the dataset with the metric values
        we want to compare. 
        E.g.: the fractional occupancies.

    class_colum : str.
        Specify the name of the column that contains
        the class/group/session/condition information.

    n_perm : int. Default 5000.
        Select the number of permutations to perform.

    alternative : str. Default=&#39;two-sided&#39;.
        Select the test type. Options are &#39;less&#39;, &#39;two-sided&#39;,
        &#39;greater&#39;.

    Returns:
    --------
    results : pd.dataframe.
        Contains the results of the permutation tests.
    &#34;&#34;&#34;
    #Validation of input data
    if class_column is None:
        raise ValueError(&#34;You must specify the &#39;class_column&#39;.&#34;)
    elif class_column not in data.columns:
        raise ValueError(f&#34;The &#39;class_column&#39; &#39;{class_column}&#39; not founded in &#39;data&#39;!&#34;)
    if not isinstance(n_perm,int):
        raise TypeError(&#34;&#39;n_perm&#39; must be an integer!&#34;)
    
    features = [col for col in data if col!=class_column] #list with variables to be tested
    n_tests = len(features) #number of tests that will be executed
    groups = np.unique(data[class_column]) #get the groups names.
    results = [] #list to save results

    for col in features:
        x1 = data[data[class_column]==groups[0]][col].values #data of first group.
        x2 = data[data[class_column]==groups[1]][col].values #data of the other group.

        #running Levene&#39;s test
        _,p_levene = levene(x1,x2,center=&#39;mean&#39;)

        #running the permutation test
        test = ttest_ind(
            x1,
            x2,
            alternative=alternative,
            permutations=n_perm,
            equal_var=True if p_levene&gt;0.05 else False
        )
        
        #computing effect size
        eff = hedges_g(x1,x2)

        results.append({
            #&#39;k&#39;: k,
            &#39;variable&#39;:col, 
            &#39;group_1&#39;:groups[0],
            &#39;group_2&#39;:groups[-1],
            &#39;statistic&#39;:test.statistic,
            &#39;p-value&#39;:test.pvalue,
            &#39;test&#39;:&#39;t-test&#39; if p_levene&gt;0.05 else &#39;welch&#39;,
            &#39;effect_size&#39;:eff
            })

    results = pd.DataFrame(results)

    #Bonferroni correction for multiple testing comparison
    results[&#39;alpha_Bonferroni&#39;] = 0.05/n_tests
    results[&#39;reject_null&#39;] = [True if p&lt;(0.05/n_tests) else False for p in results[&#39;p-value&#39;].values]

    return results</code></pre>
</details>
</dd>
<dt id="pyleida.stats.permtest_rel"><code class="name flex">
<span>def <span class="ident">permtest_rel</span></span>(<span>data, class_column=None, n_perm=5000, alternative='two-sided')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a permutation test on two related-paired
groups for each variable or feature in 'data', and
additionally computes a Bonferroni-corrected alpha.</p>
<h2 id="params">Params:</h2>
<p>data : pd.dataframe.
Contains the dataset with the metric values
we want to compare. E.g.: the fractional occupancies.</p>
<p>class_colum : str.
Specify the name of the column that contains
the class/group/session/condition information.</p>
<p>n_perm : int. Default 5000.
Select the number of permutations to perform.</p>
<p>alternative : str. Default='two-sided'.
Select the test type. Options are 'less', 'two-sided', 'greater'.</p>
<h2 id="returns">Returns:</h2>
<p>results : pd.dataframe.
Contains the results of the permutation test.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permtest_rel(data,class_column=None,n_perm=5_000,alternative=&#39;two-sided&#39;):
    &#34;&#34;&#34;
    Compute a permutation test on two related-paired
    groups for each variable or feature in &#39;data&#39;, and
    additionally computes a Bonferroni-corrected alpha.

    Params:
    -------
    data : pd.dataframe.
        Contains the dataset with the metric values
        we want to compare. E.g.: the fractional occupancies.

    class_colum : str.
        Specify the name of the column that contains
        the class/group/session/condition information.

    n_perm : int. Default 5000.
        Select the number of permutations to perform.

    alternative : str. Default=&#39;two-sided&#39;.
        Select the test type. Options are &#39;less&#39;, &#39;two-sided&#39;, &#39;greater&#39;.

    Returns:
    --------
    results : pd.dataframe.
        Contains the results of the permutation test.
    &#34;&#34;&#34;
    #Validation of input data
    if class_column is None:
        raise ValueError(&#34;You must specify the &#39;class_column&#39;.&#34;)
    elif class_column not in data.columns:
        raise ValueError(f&#34;The &#39;class_column&#39; &#39;{class_column}&#39; is not present in &#39;data&#39;!&#34;)
    if not isinstance(n_perm,int):
        raise TypeError(&#34;&#39;n_perm&#39; must be an integer!&#34;)
    
    features = [col for col in data if col!=class_column] #list with variables to be tested
    n_tests = len(features) #number of tests that will be executed
    groups = np.unique(data[class_column]) #get the groups names.
    results = [] #list to save results
    rng = np.random.default_rng()

    for col in features:
        x1 = data[data[class_column]==groups[0]][col].values #data of first group.
        x2 = data[data[class_column]==groups[1]][col].values #data of the other group.

        #running the permutation test
        test = permutation_test(
            (x1, x2), 
            _statistic, 
            n_resamples=n_perm, 
            vectorized=True, 
            alternative=alternative,
            permutation_type=&#39;samples&#39;,
            random_state=rng
            )

        #computing effect size
        eff = hedges_g(x1,x2,paired=True)

        results.append({
            #&#39;k&#39;: k,
            &#39;variable&#39;:col, 
            &#39;group_1&#39;:groups[0],
            &#39;group_2&#39;:groups[-1],
            &#39;statistic&#39;:test.statistic,
            &#39;p-value&#39;:test.pvalue,
            &#39;effect_size&#39;:eff
            })

    results = pd.DataFrame(results)

    #Bonferroni correction for multiple testing comparison
    results[&#39;alpha_Bonferroni&#39;] = 0.05/n_tests
    results[&#39;reject_null&#39;] = [True if p&lt;(0.05/n_tests) else False for p in results[&#39;p-value&#39;].values]

    return results</code></pre>
</details>
</dd>
<dt id="pyleida.stats.scatter_pvalues"><code class="name flex">
<span>def <span class="ident">scatter_pvalues</span></span>(<span>pooled_stats, metric='occupancies', fill_areas=True, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a scatter plot showing the computed
p-values for each cluster in each clustering
partition ('k'). In addition, the plot shows
the significance thresholds defined by the
standard alpha value (0.05) and the Bonferroni-corrected
alpha for each k (0.05/k).</p>
<h2 id="params">Params:</h2>
<p>pooled_stats : pandas.dataframe.
Contain the computed statistics for each
cluster and for each k.</p>
<p>metric : str. Optional.
Specify the provided metric. Just used for
plot title. If None, no title is shown.</p>
<p>fill_areas : bool.
Whether to fill with color the areas
defined by the two significance thresholds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter_pvalues(pooled_stats,metric=&#39;occupancies&#39;,fill_areas=True,darkstyle=False):
    &#34;&#34;&#34;
    Create a scatter plot showing the computed
    p-values for each cluster in each clustering
    partition (&#39;k&#39;). In addition, the plot shows
    the significance thresholds defined by the
    standard alpha value (0.05) and the Bonferroni-corrected
    alpha for each k (0.05/k).

    Params:
    -------
    pooled_stats : pandas.dataframe.
        Contain the computed statistics for each
        cluster and for each k.

    metric : str. Optional.
        Specify the provided metric. Just used for
        plot title. If None, no title is shown.

    fill_areas : bool.
        Whether to fill with color the areas
        defined by the two significance thresholds.
    &#34;&#34;&#34;
    pooled_stats.rename(columns={&#39;alpha_Bonferroni&#39;:&#39;bonf&#39;,&#39;p-value&#39;: &#39;p&#39;},inplace=True)

    K_min = min(np.unique(pooled_stats.k))
    K_max = max(np.unique(pooled_stats.k))
    alpha3 = np.sum(np.arange(K_min,K_max+1,1))

    #Create list assigning a color to each pvalue.
    color_list = []
    for pval,bonf in zip(pooled_stats.p,pooled_stats.bonf):
        color_list.append(&#39;mediumseagreen&#39; if 0.05/alpha3&lt;pval&lt;bonf 
                        else &#39;firebrick&#39; if 0.05&gt;pval&gt;bonf
                        else &#39;royalblue&#39; if pval&lt;0.05/alpha3
                        else (&#39;black&#39; if not darkstyle else &#39;white&#39;)
                        )

    #adding data to bonferroni alphas so we can plot from K-min-1 to K_max+1
    bonf_data = pooled_stats[[&#39;k&#39;,&#39;bonf&#39;]]
    bonf_data.loc[len(bonf_data.index)] = [K_min-1,0.05/(K_min-1)]
    bonf_data.loc[len(bonf_data.index)] = [K_max+1,0.05/(K_max+1)]
    bonf_data = bonf_data.sort_values(by=&#39;k&#39;).reset_index(drop=True) 

    #plotting
    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        plt.ion()
        plt.figure(figsize=(11,6))
        plt.scatter(pooled_stats.k,pooled_stats.p,c=color_list,s=2)
        plt.axhline(0.05,linestyle=&#34;dashed&#34;,c=&#39;firebrick&#39;,label=r&#39;$\alpha^{1}$ = 0.05&#39;)

        plt.plot(
            bonf_data.k,
            bonf_data.bonf,
            linestyle=&#34;dashed&#34;,
            c=&#39;mediumseagreen&#39;,
            label=r&#39;$\alpha^{2}$ = $\alpha^{1}$ / k&#39;
            )

        plt.axhline(
            0.05/alpha3,
            linestyle=&#34;dashed&#34;,
            c=&#39;royalblue&#39;,
            label=r&#39;$\alpha^{3}$ = $\alpha^{1}$ / Σ (k)&#39;
            ) #alpha 3 = Σk / 0.05

        plt.yscale(&#39;log&#39;)
        plt.xlabel(&#39;Number of PL states in\neach clustering solution (K)&#39;,fontsize=15)
        plt.ylabel(&#39;Two-sided p-value&#39;,fontsize=15)
        plt.xticks(np.arange(K_min,K_max+1),[k for k in np.arange(K_min,K_max+1)])
        plt.xlim(left=K_min-1,right=K_max+1)
        plt.ylim(bottom=0.00000001)
        if metric is not None:
            title = f&#34;{str(metric).capitalize().replace(&#39;_&#39;,&#39; &#39;)}: {np.unique(pooled_stats.group_1)[0]} vs {np.unique(pooled_stats.group_2)[0]}&#34;
            plt.title(title,fontsize=20,pad=20)
        plt.legend(bbox_to_anchor=(1.05, 1.0), loc=&#39;upper left&#39;)

        if fill_areas:
            plt.fill_between(
                np.arange(K_min-1,K_max+2), 
                np.flip(np.unique(bonf_data.bonf)), 
                0.05/alpha3,
                alpha=0.15,
                color=&#39;mediumseagreen&#39;
                )
            plt.fill_between(
                np.arange(K_min-1,K_max+2),
                np.flip(np.unique(bonf_data.bonf)),
                0.05,
                alpha=0.15,
                color=&#39;firebrick&#39;
                )
            plt.fill_between(
                np.arange(K_min-1,K_max+2),
                -1,
                0.05/alpha3,
                alpha=0.15,
                color=&#39;royalblue&#39;
                )

        plt.tight_layout()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
    <a href="https://sites.google.com/view/psychomark/home">
        <img src="../imgs/psychomark_logo.png" alt="logo" width="150" height="100"/>
    </a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyleida" href="../index.html">pyleida</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyleida.stats._compute_stats" href="#pyleida.stats._compute_stats">_compute_stats</a></code></li>
<li><code><a title="pyleida.stats.hedges_g" href="#pyleida.stats.hedges_g">hedges_g</a></code></li>
<li><code><a title="pyleida.stats.ks_distance" href="#pyleida.stats.ks_distance">ks_distance</a></code></li>
<li><code><a title="pyleida.stats.permtest_ind" href="#pyleida.stats.permtest_ind">permtest_ind</a></code></li>
<li><code><a title="pyleida.stats.permtest_rel" href="#pyleida.stats.permtest_rel">permtest_rel</a></code></li>
<li><code><a title="pyleida.stats.scatter_pvalues" href="#pyleida.stats.scatter_pvalues">scatter_pvalues</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>