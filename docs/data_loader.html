<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyleida._data_loader API documentation</title>
<meta name="description" content="Class to retrieve and explore the LEiDA results." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
    <a href="https://sites.google.com/view/psychomark/home">
        <img src="imgs/psychomark_logo.png" alt="logo" width="150" height="100"/>
    </a>
<h1 class="title"><code>pyleida.DataLoader</code></h1>
</header>
<section id="section-intro">
<p>Class to retrieve and explore the LEiDA results.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class to retrieve and explore the LEiDA results.&#34;&#34;&#34;

import numpy as np
import pandas as pd
import os
from itertools import combinations
import matplotlib.pyplot as plt
import seaborn as sns

from .data_utils import (
    load_rois_labels,
    load_rois_coordinates, 
    load_tseries,
    load_classes
)
from .data_utils.validation import (
    _check_k_input,
    _check_metric,
    _check_state
)
from .plotting import (
    brain_states_network,
    brain_states_nodes,
    plot_pyramid,
    states_k_glass,
    states_in_bold,
    brain_states_on_surf,
    brain_states_on_surf2,
    _explore_state,
    _save_html
)
from .clustering import (
    barplot_states,
    barplot_eig,
    centroid2matrix,
    plot_clusters3D,
    plot_voronoi,
    plot_clustering_scores
)
from .clustering import rsnets_overlap as rsnets
from .dynamics_metrics import group_transition_matrix
from .stats import scatter_pvalues


class DataLoader:
    &#34;&#34;&#34;
    Class to retrieve from local folder all
    the outputs and results of the execution
    of the LEiDA pipeline through the &#39;Leida&#39;
    class provided in the package. The DataLoader
    provides the same methods of the Leida class,
    thus allowing to load and deepen easily in the
    results of the previously executed analysis.

    Params:
    -------
    data_path : str.
        Path to the folder that contains the
        BOLD time series, metadata, ROIs labels, 
        and ROIs coordinates.

    results_path : str.
        Path to the folder that contains the
        LEiDA results. (default: &#39;LEiDA_results&#39;)

    Attributes:
    -----------
    eigenvectors : pandas.dataframe.
        Contains the computed eigenvectors
        for each time point of each subject.

    predictions : pandas.dataframe.
        Contains the predicted cluster label of
        each eigenvector for each &#39;k&#39; partition
        explored.

    rois_labels : list.
        The label/name of each ROI/parcel.

    rois_coordinates_ : ndarray of shape (n_rois,3).
        The MNI coordinates of each ROI/parcel.
    &#34;&#34;&#34;
    def __init__(self,data_path=&#39;data&#39;,results_path=&#39;LEiDA_results&#39;):
        #validation of input data
        for _path in (data_path,results_path):
            if not isinstance(_path,str):
                raise TypeError(&#34;&#39;data_path&#39; and &#39;results_path&#39; must be strings!&#34;)
        #check if the provided paths exists
        if not os.path.exists(data_path):
            raise ValueError(&#34;The provided &#39;data_path&#39; could&#39;t be founded.&#34;)
        if not os.path.exists(results_path):
            raise ValueError(&#34;The provided &#39;results_path&#39; could&#39;t be founded.&#34;)
        
        #Paths in which the data and results are stored
        self._data_path_ = data_path
        self._results_path_ = results_path
        self._clustering_ = results_path + &#39;/clustering&#39;
        self._dynamics_ = results_path + &#39;/dynamics_metrics&#39;
        self._models_ = self._clustering_ + &#39;/models&#39;

        #check if the &#39;clustering&#39; and &#39;dynamics_metrics&#39; folders exists in &#39;results_path&#39;
        if not os.path.exists(self._clustering_) or not os.path.exists(self._dynamics_):
            raise Exception(f&#34;No results were found in the specified path.&#34;)
        
        #load eigenvectors and kmeans predictions dataframes.
        try:
            self.eigenvectors = pd.read_csv(f&#39;{results_path}/eigenvectors.csv&#39;,sep=&#39;\t&#39;)
            nrois = self.eigenvectors.shape[1]-2
        except:
            raise Exception(&#34;The eigenvectors dataframe could&#39;t be loaded.&#34;)
        try:
            self.predictions = pd.read_csv(f&#39;{self._clustering_}/predictions.csv&#39;,sep=&#39;\t&#39;)
        except:
            raise Exception(&#34;The dataframe with the KMeans models predictions couldn&#39;t be loaded.&#34;)

        #load rois labels
        self.rois_labels = load_rois_labels(self._data_path_)
        nlabels = len(self.rois_labels)

        #load rois coordinates
        self.rois_coordinates_ = load_rois_coordinates(self._data_path_)
        if self.rois_coordinates_ is None:
            print(&#34;The ROIs coordinates couldn&#39;t be loaded from the provided &#39;data_path&#39;. &#34;
                &#34;Brain plots that show nodes in brain space will not be executed in consequence.&#34;)
        else:
            ncoords = self.rois_coordinates_.shape[0]

        #check that the N of ROIs coincide across
        #labels, coordinates, and eigenvectors
        if self.rois_coordinates_ is None:
            if not nrois==nlabels:
                raise Exception(f&#34;The number of ROIs in &#39;eigenvectors.csv&#39; ({nrois}) &#34;
                                f&#34;and &#39;rois_labels.txt&#39; {nlabels} must coincide!&#34;)
        else:
            if not nrois==nlabels==ncoords:
                raise Exception(f&#34;The number of ROIs in &#39;eigenvectors.csv&#39; ({nrois}), &#34;
                                f&#34;&#39;rois_labels.txt&#39; ({nlabels}), and &#39;rois_coordinates.csv&#39; &#34;
                                f&#34;({ncoords}) must coincide!&#34;)

        self._K_min_ = 2
        self._K_max_ = 20

        self._classes_lst_ = np.unique(self.eigenvectors.condition).tolist()
        self._N_classes_ = len(self._classes_lst_)

    def time_series(self):
        &#34;&#34;&#34;
        Return a dictionary having the &#39;subject_ids&#39;
        as keys, and 2D arrays (N_ROIs,N_volumes) with
        BOLD time series as values.

        Returns:
        --------
        time_series : dict.
        &#34;&#34;&#34;
        return load_tseries(self._data_path_)

    def load_model(self,k=2):
        &#34;&#34;&#34;
        Load fitted model for a specific &#39;k&#39; partition.
        Given that each model is an instance of the KMeansLeida
        class, once loaded you can access all the object methods
        and attributes.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        model : KMeansLeida instance.
            The fitted model that was used to predict
            the cluster labels of each observation.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            model = pd.read_pickle(f&#39;{self._models_}/model_k_{k}.pkl&#39;)
            return model
        except:
            raise Exception(&#34;Can&#39;t find results for the selected k.&#34;)

    def load_centroids(self,k=2):
        &#34;&#34;&#34;
        Return the computed clusters centroids
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        centroids : pd.DataFrame with shape (n_centroids,n_rois).
            Contains the computed centroids for
            the selected k partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)

        return centroids

    def centroids_distances(self,k=2):
        &#34;&#34;&#34;
        Transform eigenvectors to a cluster-distance space. 
        Returns the distance between each eigenvector and the
        cluster centroids of the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        --------
        distances : pd.DataFrame.
            Contains the distace between each eigenvector and
            each cluster centroid for the select &#39;k&#39; partition.
            1st column contains &#39;subject_id&#39;, 2nd column the
            &#39;condition&#39;, and the rest of columns the distances
            to the centroids.
        &#34;&#34;&#34;
        model = self.load_model(k=k)
        distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
        distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
        distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
        return distances

    def stats(self,k=2,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Retrieve the results from the statistical analysis of 
        a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the &#39;k&#39; partition of interest.

        metric : str.
            Select the metric to retrieve results.

        Returns:
        --------
        stats : pandas.dataframe.
            Results of the statistical analysis
            of each PL state.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_metric(metric)

        try:
            df_stats = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k or metric.&#34;)
        return df_stats

    def dwell_times(self,k=2):
        &#34;&#34;&#34;
        Return the computed dwell times of each
        phase-locking state for a specific &#39;k&#39;
        partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        dwell_times : pd.DataFrame.
            Contains the computed dwell times of each
            PL state for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            dt = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/dwell_times.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return dt
    
    def occupancies(self,k=2):
        &#34;&#34;&#34;
        Return the computed fractional occupancy of each
        phase-locking state for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of
            interest.

        Returns:
        --------
        occupancies : pd.DataFrame.
            Contains the computed fractional occupancy
            of each PL state for each subject for the
            selected &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            occ = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/occupancies.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return occ

    def transitions(self,k=2):
        &#34;&#34;&#34;
        Return the computed transition probabilities between
        phase-locking states for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        transitions : pd.DataFrame.
            Contains the computed transition probabilities
            between PL states for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            tr = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return tr
    
    def significant_states(self,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Return a dataframe containing only the statistics
        of the phase-locking states that are significantly
        different between groups.

        Params:
        -------
        metric : str.
            Metric of interest (Options: &#39;occupancies&#39;,
            &#39;dwell_times&#39;).

        Returns:
        --------
        stats : pandas.dataframe.
        &#34;&#34;&#34;
        _check_metric(metric)

        try:
            stats = self._pool_stats(metric=metric)
        except:
            raise Exception(&#34;The stats could&#39;t be loaded.&#34;)
        has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
        if has_results:
            return stats[stats.reject_null==True]
        else:
            print(&#34;No significant results were detected.&#34;)
            return None
        
    def state_rois(self,k=2,state=1):
        &#34;&#34;&#34;
        Get a list with the names of the ROIs/parcels that
        participates in a specific phase-locking (PL) state.

        Params:
        -------
        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        Returns:
        --------
        rois : list.
            Contains the names of the ROIs that
            are part of the selected PL state.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
        data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
        rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
        return rois

    def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute the mean static functional
        connectivity matrix of a particular
        group/condition.

        Params:
        --------
        group : str.
            Specify the group of interest.

        plot : bool.
            Whether to create a heatmap showing
            the connectivity matrix.

        cmap : str.
            If plot=True, then select the colormap
            to use for the heatmap. Default = &#39;jet&#39;.

        darkstyle : bool.
            Whether to use a dark background
            for plotting.

        Returns:
        --------
        static_fc : ndarray with shape (N_ROIs, N_ROIs).
            The computed static functional connectivity
            matrix.
        &#34;&#34;&#34;
        if not isinstance(group,str):
            raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

        classes = load_classes(self._data_path_)

        #create list with conditions labels
        conditions = []
        for val in classes.values():
            for item in val:
                conditions.append(item)

        if len(conditions) != len(self.time_series().keys()):
            raise Exception(&#34;This method is only available in &#34;
                &#34;cases where each subject has only one condition label.&#34;)
        if group not in conditions:
            raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
                f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

        signals = load_tseries(self._data_path_)
        subjects_ids = [sub for sub,condition in zip(signals.keys(),conditions) if condition==group]
        N_subjects = len(subjects_ids)
        N_rois = len(self.rois_labels)
        pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
        
        for idx,sub in enumerate(subjects_ids):
            pooled_static_fc[:,:,idx] = np.corrcoef(signals[sub])
        
        static_fc = np.mean(pooled_static_fc,axis=-1)

        if plot:
            plt.ion()
            with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
                plt.figure()
                sns.heatmap(
                    static_fc,
                    vmin=-1,
                    vmax=1,
                    center=0,
                    square=True,
                    cmap=cmap,
                    cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
                )

                plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.title(group)
                plt.xticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist(),
                        rotation=0
                        )
                plt.yticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist()
                        )
                plt.tick_params(
                    axis=&#39;both&#39;,         
                    which=&#39;both&#39;,     
                    bottom=False,
                    left=False
                    )
                plt.tight_layout()
                #plt.show()

        return static_fc

    def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute and plot the mean or median transition
        probabilities matrix of each group/condition.

        Params:
        -------
        k : int.
            The k-means partition of interest.

        metric : str.
            Whether to plot the &#39;mean&#39; or &#39;median&#39;
            matrices.

        cmap : str.
            Colormap to use in the created heatmaps.

        darkstyle : bool.
            Whether to use a dark background for
            plotting.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        data = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)

        mats = group_transition_matrix(
            data,
            metric=metric,
            cmap=cmap,
            darkstyle=darkstyle
            )

        return mats

    def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
        &#34;&#34;&#34;
        Compute the overlap between the 7 resting-state
        networks defined in Yeo et al. (2011) and the brain
        cortical regions/parcels of the phase-locking state
        of interest. The correlations are shown in a barplot,
        and a dataframe with the correlations and p-values is
        returned.

        Params:
        --------
        parcellation : str.
            Specify path to your parcellation .nii file.
            Note: the parcellation must be of 2mm resolution.

        n_areas : None | int.
            Analyze only the first n areas from the provided
            parcellation. 
            Usefull when the parcellation contains subcortical
            regions that must be ignored when computing the overlap
            with Yeo&#39;s cortical networks.

        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        darkstyle : bool.
            Whether to use a dark theme for the plot.

        Returns:
        --------
        overlap : pandas.dataframe with shape (7networks,3).
            Contains the correlation coefficient (and p-value)
            between the selected phase-locking state and each
            of the 7 resting-state networks from Yeo (2011).
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centr = {}

        for k_ in range(self._K_min_,self._K_max_+1):
            cent = self.load_centroids(k_)
            cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
            cent.insert(0,&#39;k&#39;,k_)
            centr[f&#39;k{k_}&#39;] = cent
        
        centr = pd.concat(centr,ignore_index=True)

        corr,pvals = rsnets.compute_overlap(
            centr,
            parcellation=parcellation,
            n_areas=n_areas
            )

        overlap = rsnets.state_overlap(
            corr,
            pvals,
            k=k,
            state=state,
            plot=True,
            darkstyle=darkstyle
            )

        return overlap

    def _pool_stats(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the stats for each k for the selected
        metric in a single dataframe.

        Params:
        --------
        metric : str.
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        data_path = self._dynamics_
        #get list with folder names
        k_folders = [folder for folder in os.listdir(data_path) 
                    if os.path.isdir(os.path.join(data_path,folder)) 
                    and folder.startswith(&#39;k_&#39;)]

        stats_all = []
        for folder in k_folders:
            stats_all.append(
                pd.read_csv(f&#39;{data_path}/{folder}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;)
                )
        stats_all = pd.concat((stats_all),ignore_index=True)

        stats_all = stats_all.sort_values(by=&#39;k&#39;).reset_index(drop=True)

        return stats_all

    def _pool_dynamics_metric(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the computed values for each k for the
        selected metric in a dictionary.

        Params:
        --------
        metric : str.
            Specify the metric of interest.
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        data_path = self._dynamics_
        #get list with folder names
        k_folders = [folder for folder in os.listdir(data_path)
                    if os.path.isdir(os.path.join(data_path,folder)) 
                    and folder.startswith(&#39;k_&#39;)]

        pooled_metric = {}
        for folder in k_folders:
            pooled_metric[folder] = pd.read_csv(f&#39;{data_path}/{folder}/{metric}.csv&#39;,sep=&#39;\t&#39;)

        return pooled_metric

    #plotting methods

    def plot_states_nodes(self,k=2,state=&#39;all&#39;,node_size=15,show_labels=True,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states in anatomical MNI space. Each parcel/ROI
        is represented as a node. Nodes that are part of
        the PL pattern are coloured in red, and the rest
        of nodes are coloured in blue.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size: int or float.
            Define the size of the nodes. Nodes
            that don&#39;t belong to the pattern are
            plotted smaller.

        show_labels : bool.
            Whether to show each ROI label.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates_ is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        centroids = self.load_centroids(k=k).values
        plots = brain_states_nodes(
            centroids,
            self.rois_coordinates_,
            node_size=node_size,
            state=state,
            nodes_labels=None if not show_labels else self.rois_labels,
            open=open
            )
        
        if save:
            _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

        return plots
    
    def plot_states_network(self,k=2,state=&#39;all&#39;,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states as a connected network. All the ROIs/parcels
        that belong to the selected phase-locking state are
        connected between each other.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size : int. 
            Select the size of the nodes.

        node_color : str. 
            Select the color of the nodes. If
            &#39;infer&#39;, then the nodes participating
            in the PL states are colored red and
            the rest blue. If &#39;black&#39;, then all the
            nodes are colored in the same way.

        linewidth : int. 
            Select the size of the edges
            connecting the nodes.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates_ is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        _check_k_input(self._K_min_,self._K_max_,k)
        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state.&#34;)
        elif isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values #load centroids for the selected k

        #plotting
        plot = brain_states_network(
            centroids,
            self.rois_coordinates_,
            state=state,
            node_size=node_size,
            node_color=node_color,
            linewidth=linewidth,
            open=open
            )

        #saving figures
        if save:
            _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)

        return plot

    def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
        &#34;&#34;&#34;
        Create a pyramid of barplots showing the &#39;metric&#39;
        of interest for each group, cluster (PL state), and
        K partition. Each barplot (which represents a particular
        PL state) is coloured according to its associated p-value:
        -black: the p-value is higher than 0.05.
        -red: the p-value is lower than 0.05 but higher than 0.05 / k.
        -green: the p-value is lower than 0.05/k but higher than 0.05 / Σ(k).
        -blue: the p-value is lower than 0.05 / Σ(k).

        Params:
        -------
        metric : str.
            Select the dynamical systems theory metric
            of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

        conditions : None | list. Optional.
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        despine : bool. Default = True.
            Whether to despine top and right axes of the
            subplots.
        &#34;&#34;&#34;
        _check_metric(metric)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)
        K_min = np.min(pooled_stats.k)
        K_max = np.max(pooled_stats.k)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            dyn_metric = self._pool_dynamics_metric(metric=metric) 
            dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

            plot_pyramid(
                dyn_metric,
                pooled_stats_,
                K_min=K_min,
                K_max=K_max,
                despine=despine
                )

    def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
        &#34;&#34;&#34;
        Visualize the identified clusters (BOLD phase-locking
        states) in a 3D scatter plot, which constitutes a
        low-dimensional representation of the &#39;state space&#39;. 
        Method : take the eigenvectors and extract the first
        three principal components to reduce the dimensionality
        of the data to a 3D space. Each dot in the plot thus
        represents a single eigenvector, and is coloured according
        to the cluster it belongs to.
        
        Params:
        -------
        k : int.
            Specify the partition to plot.

        clusters_colors : list (optional). 
            Provide a list with the desired color
            of each cluster. If not provided, then
            a predefined set of colors will be used.

        grid : bool. 
            Whether to show grid or not.

        alpha : float. 
            Set transparency of dots.

        dot_size : float. 
            Select the dot size.

        edge_color : None | str.
            Specify an edge color to use
            on dots.

        darkstyle : bool.
            Whether to use a dark theme for
            the plot.
        &#34;&#34;&#34;
        X = self.eigenvectors.iloc[:,2:].values #keep array containing only the eigenvectors
        y = self.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plot_clusters3D(
                X,
                y,
                clusters_colors=clusters_colors,
                grid=grid,
                alpha=alpha,
                dot_size=dot_size,
                edgecolor=edgecolor
                )

    def barplot_centroids(self,k=2,state=&#39;all&#39;):
        &#34;&#34;&#34;
        Create either subplots with barplots showing the
        values of each cluster centroid for the selected &#39;k&#39;
        partition, or a single barplot showing the values
        of a specific phase-locking state.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : str or int.
            Specify if plot all the states for
            the selected &#39;k&#39;, or a single state
            of interest.
        &#34;&#34;&#34;
        centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
        if state==&#39;all&#39;:
            barplot_states(centroids,self.rois_labels)
        else:
            _check_state(k,state)
            barplot_eig(centroids[state-1,:],self.rois_labels)
            plt.title(f&#39;PL pattern {state}&#39;,fontsize=18)
            plt.tight_layout()

    def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
        &#34;&#34;&#34;
        Create a scatter plot showing the p-values
        obtained by the statistical analysis of a given
        &#39;metric&#39; across the explored &#39;k&#39; range.

        Params:
        -------
        metric : str. 
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

        conditions : None | list. Optional
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.

        fill_areas : bool.
            Select whether to fill the significance
            areas with color.
        &#34;&#34;&#34;
        _check_metric(metric)

        if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)

    def plot_voronoi_cells(self,k=2):
        &#34;&#34;&#34;
        Plot the clusters centroids in a 2D Voronoi
        cells space. Performs a PCA to reduce the
        dimensionality of the original centroid space
        to a 2D space.

        Params:
        --------
        k : int.
            Select the clustering solution to plot.

        Note: see Vohryzek, Deco et al. (2020) p.4
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = self.load_centroids(k=k).values 
        plot_voronoi(centroids)

    def plot_clustering_performance(self):
        &#34;&#34;&#34;
        Create a 2x2 panel with lineplots showing
        the clustering evaluation metrics for each
        k partition explored (Dunn score, distortion,
        silhouette score, and Davis-Bouldin score).
        &#34;&#34;&#34;
        performance = pd.read_csv(f&#39;{self._clustering_}/clustering_performance.csv&#39;,sep=&#39;\t&#39;)
        plot_clustering_scores(performance)

    def plot_states_network_glass(self,k=2,darkstyle=False):
        &#34;&#34;&#34;
        Create a glass brain (axial view) showing the
        network representation of each phase-locking
        (PL) state for the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        pl_states = self.load_centroids(k=k).values

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_k_glass(pl_states,self.rois_coordinates_,darkstyle=darkstyle)

    def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
        &#34;&#34;&#34;
        Create plot showing the time-series of BOLD signals, 
        highlighting the dominant phase-locking (PL) state
        of each time point or volume.

        Params:
        -------
        subject_id : str.
            Specify the &#39;id&#39; of the subject
            of interest.

        k : int.
            Select the k partition.

        alpha : float.
            Transparency of the colors that
            show the dominant PL pattern of
            each time point.

        darkstyle : bool.
            Whether to create the plot using
            a darkstyle.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        signals = load_tseries(self._data_path_)
        signals = signals[subject_id][:,1:-1] #get subject signals (and exclude 1st and last volumes)
        y = self.predictions[self.predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            states_in_bold(signals,y,alpha=alpha)

    def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states on cortical surface. By default, all the
        cortical regions that belong to a given PL state
        or pattern are coloured in red(s), while the rest
        of cortical regions are coloured in blue(s). You
        can change the colormap throught the &#39;cmap&#39; argument.

        Params:
        -------
        k : int.
            Partition of interest.

        state : str or int.
            Whether to plot &#39;all&#39; the PL states of
            the selected partition or a single state
            of interest.

        parcellation : str.
            Path to the .nii file containing the
            parcellation from which the time series
            were extracted.

        discretize : bool. Default = True.
            Whether to plot the raw values of the
            phase-locking state/centroid, or plot
            all the brain regions that belong to
            the phase-locking state with the same
            intensity.

        cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
            Colormap to use in the brain plot.
            If &#39;auto&#39;, then the brain regions that
            belong to the phase-locking state will
            be coloured in red(s), and the rest of
            regions in blue(s).

        darkstyle : bool.
            Whether to use a black background.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        g : SurfaceView or dictionarity of SurfaceViews. 
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer specifying the number of a particular PL state&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        if state!=&#39;all&#39;:
            centroids = centroids[state-1,:]
        
        g = brain_states_on_surf(
            centroids,
            parcellation=parcellation,
            black_bg=darkstyle,
            open=open,
            discretize=discretize,
            cmap=cmap
            )

        if save:
            _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

        return g

    def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
        &#34;&#34;&#34;
        Plot a BOLD phase-locking state of interest 
        on cortical surface mesh. 

        Params:
        -------
        k : int.
            Partition of interest.

        state : int.
            Select the PL state/pattern of
            interest.

        parcellation : str.
            Path to the .nii file containing
            the parcellation from which the
            signals were extracted.

        surface : str.
            Specify the surface type to plot
            the pattern on. Valid options are
            &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

        hemi : str.
            Select the hemisphere to plot.
            Valid options are &#39;right&#39;, &#39;left&#39;,
            or &#39;both&#39;.

        view : str
            View of the surface that is rendered. 
            Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
            &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
            &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
            and &#39;lateral&#39; views are displayed.

        darkstyle : bool
            Whether to use a black background.

        save : bool.
            Whether to save the created figure in
            local folder. If True, the files are
            saved in &#39;LEiDA_results/brain_plots&#39;,
            and the plot will not be displayed.

        Returns:
        --------
        g : matplotlib figure. 
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        centroid = centroids[state-1,:]

        #plotting
        print(&#34;\n-Creating plot. This may take &#34;
            &#34;some minutes. Please wait...&#34;)
            
        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            g = brain_states_on_surf2(
                centroid,
                parcellation=parcellation,
                hemi=hemi,
                surface=surface,
                view=view
                )
        
        if save:
            try:
                path = f&#39;{self._results_path_}/brain_plots&#39;
                if not os.path.exists(path): 
                    os.makedirs(path)
                filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}.png&#34;
                g.savefig(filename,dpi=300)
                plt.close()
                del g
                print(f&#34;The plot was save at: {filename}&#34;)
            except:
                raise Exception(&#34;An error occured when saving the plot.&#34;)
        else:
            return g

    def explore_state(self,k=2,state=1,darkstyle=False):
        &#34;&#34;&#34;
        Create a figure showing a phase-locking state of
        interest in different formats:
        a barplot, a network representation in brain space,
        a matrix representation, and two boxplots with the
        occupancies and dwell times for each group/condition.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : int.
            Select the PL state of interest.

        darkstyle : bool.
            Whether to use a dark background.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroid = self.load_centroids(k=k).values
        centroid = centroid[state-1,:]

        occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
        dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            _explore_state(
                centroid,
                self.rois_labels,
                occ,
                dt,
                self.rois_coordinates_,
                state_number=state,
                darkstyle=darkstyle
                )

    def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Take the controids resulting from the k-means
        clustering (i.e., the phase-locking states) and
        reconstruct the connectivity patterns in matrix
        format.

        Params:
        -------
        k : int.
            Specify the K partition of interest.
        
        cmap : str. Default = &#39;jet&#39;.
            Select the colormap to use.

        darkstyle : bool.
            Whether to use a black background.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(cmap,str):
            raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
        if not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

        _ = centroid2matrix(
            self.load_centroids(k).values,
            plot=True,
            cmap=cmap,
            darkstyle=darkstyle
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>

<dl>
<dt id="pyleida._data_loader.DataLoader"><code class="flex name class">
<span>class <span class="ident">DataLoader</span></span>
<span>(</span><span>data_path='data', results_path='LEiDA_results')</span>
</code></dt>
<dd>
<div class="desc"><p>Class to retrieve from local folder all
the outputs and results of the execution
of the LEiDA pipeline through the 'Leida'
class provided in the package. The DataLoader
provides the same methods of the Leida class,
thus allowing to load and deepen easily in the
results of the previously executed analysis.</p>
<h2 id="params">Params:</h2>
<p>data_path : str.
Path to the folder that contains the
BOLD time series, metadata, ROIs labels, 
and ROIs coordinates.</p>
<p>results_path : str.
Path to the folder that contains the
LEiDA results (default: 'LEiDA_results').</p>
<h2 id="attributes">Attributes:</h2>
<p>eigenvectors : pandas.dataframe.
Contains the computed eigenvectors
for each time point of each subject..</p>
<p>predictions : pandas.dataframe.
Contains the predicted cluster label
of each eigenvector for each 'k' partition
explored.</p>
<p>rois_labels : list.
The label/name of each ROI/parcel.</p>
<p>rois_coordinates_ : ndarray of shape (n_rois,3).
The MNI coordinates of each ROI/parcel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataLoader:
    &#34;&#34;&#34;
    Class to retrieve from local folder all
    the outputs and results of the execution
    of the LEiDA pipeline through the &#39;Leida&#39;
    class provided in the package. The DataLoader
    provides the same methods of the Leida class,
    thus allowing to load and deepen easily in the
    results of the previously executed analysis.

    Params:
    -------
    data_path : str.
        Path to the folder that contains the
        BOLD time series, metadata, ROIs labels, 
        and ROIs coordinates.

    results_path : str.
        Path to the folder that contains the
        LEiDA results (default: &#39;LEiDA_results&#39;).

    Attributes:
    -----------
    eigenvectors : pandas.dataframe.
        Contains the computed eigenvectors
        for each time point of each subject.

    predictions : pandas.dataframe.
        Contains the predicted cluster label
        of each eigenvector for each &#39;k&#39; partition
        explored.

    rois_labels : list.
        The label/name of each ROI/parcel.

    rois_coordinates_ : ndarray of shape (n_rois,3).
        The MNI coordinates of each ROI/parcel.
    &#34;&#34;&#34;
    def __init__(self,data_path=&#39;data&#39;,results_path=&#39;LEiDA_results&#39;):
        #validation of input data
        for _path in (data_path,results_path):
            if not isinstance(_path,str):
                raise TypeError(&#34;&#39;data_path&#39; and &#39;results_path&#39; must be strings!&#34;)
        #check if the provided paths exists
        if not os.path.exists(data_path):
            raise ValueError(&#34;The provided &#39;data_path&#39; could&#39;t be founded.&#34;)
        if not os.path.exists(results_path):
            raise ValueError(&#34;The provided &#39;results_path&#39; could&#39;t be founded.&#34;)
        
        #Paths in which the data and results are stored
        self._data_path_ = data_path
        self._results_path_ = results_path
        self._clustering_ = results_path + &#39;/clustering&#39;
        self._dynamics_ = results_path + &#39;/dynamics_metrics&#39;
        self._models_ = self._clustering_ + &#39;/models&#39;

        #check if the &#39;clustering&#39; and &#39;dynamics_metrics&#39; folders exists in &#39;results_path&#39;
        if not os.path.exists(self._clustering_) or not os.path.exists(self._dynamics_):
            raise Exception(f&#34;No results were found in the specified path.&#34;)
        
        #load eigenvectors and kmeans predictions dataframes.
        try:
            self.eigenvectors = pd.read_csv(f&#39;{results_path}/eigenvectors.csv&#39;,sep=&#39;\t&#39;)
            nrois = self.eigenvectors.shape[1]-2
        except:
            raise Exception(&#34;The eigenvectors dataframe could&#39;t be loaded.&#34;)
        try:
            self.predictions = pd.read_csv(f&#39;{self._clustering_}/predictions.csv&#39;,sep=&#39;\t&#39;)
        except:
            raise Exception(&#34;The dataframe with the KMeans models predictions couldn&#39;t be loaded.&#34;)

        #load rois labels
        self.rois_labels = load_rois_labels(self._data_path_)
        nlabels = len(self.rois_labels)

        #load rois coordinates
        self.rois_coordinates_ = load_rois_coordinates(self._data_path_)
        if self.rois_coordinates_ is None:
            print(&#34;The ROIs coordinates couldn&#39;t be loaded from the provided &#39;data_path&#39;. &#34;
                &#34;Brain plots that show nodes in brain space will not be executed in consequence.&#34;)
        else:
            ncoords = self.rois_coordinates_.shape[0]

        #check that the N of ROIs coincide across
        #labels, coordinates, and eigenvectors
        if self.rois_coordinates_ is None:
            if not nrois==nlabels:
                raise Exception(f&#34;The number of ROIs in &#39;eigenvectors.csv&#39; ({nrois}) &#34;
                                f&#34;and &#39;rois_labels.txt&#39; {nlabels} must coincide!&#34;)
        else:
            if not nrois==nlabels==ncoords:
                raise Exception(f&#34;The number of ROIs in &#39;eigenvectors.csv&#39; ({nrois}), &#34;
                                f&#34;&#39;rois_labels.txt&#39; ({nlabels}), and &#39;rois_coordinates.csv&#39; &#34;
                                f&#34;({ncoords}) must coincide!&#34;)

        self._K_min_ = 2
        self._K_max_ = 20

        self._classes_lst_ = np.unique(self.eigenvectors.condition).tolist()
        self._N_classes_ = len(self._classes_lst_)

    def time_series(self):
        &#34;&#34;&#34;
        Return a dictionary having the &#39;subject_ids&#39;
        as keys, and 2D arrays (N_ROIs,N_volumes) with
        BOLD time series as values.

        Returns:
        --------
        time_series : dict.
        &#34;&#34;&#34;
        return load_tseries(self._data_path_)

    def load_model(self,k=2):
        &#34;&#34;&#34;
        Load fitted model for a specific &#39;k&#39; partition.
        Given that each model is an instance of the KMeansLeida
        class, once loaded you can access all the object methods
        and attributes.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        model : KMeansLeida instance.
            The fitted model that was used to predict
            the cluster labels of each observation.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            model = pd.read_pickle(f&#39;{self._models_}/model_k_{k}.pkl&#39;)
            return model
        except:
            raise Exception(&#34;Can&#39;t find results for the selected k.&#34;)

    def load_centroids(self,k=2):
        &#34;&#34;&#34;
        Return the computed clusters centroids
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        -------
        centroids : pd.DataFrame with shape (n_centroids,n_rois).
            Contains the computed centroids for
            the selected k partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)

        return centroids

    def centroids_distances(self,k=2):
        &#34;&#34;&#34;
        Transform eigenvectors to a cluster-distance space. 
        Returns the distance between each eigenvector and the
        cluster centroids of the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.
        
        Returns:
        --------
        distances : pd.DataFrame.
            Contains the distace between each eigenvector and
            each cluster centroid for the select &#39;k&#39; partition.
            1st column contains &#39;subject_id&#39;, 2nd column the
            &#39;condition&#39;, and the rest of columns the distances
            to the centroids.
        &#34;&#34;&#34;
        model = self.load_model(k=k)
        distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
        distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
        distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
        return distances

    def stats(self,k=2,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Retrieve the results from the statistical analysis of 
        a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
        for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the &#39;k&#39; partition of interest.

        metric : str.
            Select the metric to retrieve results.

        Returns:
        --------
        stats : pandas.dataframe.
            Results of the statistical analysis
            of each PL state.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_metric(metric)

        try:
            df_stats = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k or metric.&#34;)
        return df_stats

    def dwell_times(self,k=2):
        &#34;&#34;&#34;
        Return the computed dwell times of each
        phase-locking state for a specific &#39;k&#39;
        partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        dwell_times : pd.DataFrame.
            Contains the computed dwell times of each
            PL state for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            dt = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/dwell_times.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return dt
    
    def occupancies(self,k=2):
        &#34;&#34;&#34;
        Return the computed fractional occupancy of each
        phase-locking state for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of
            interest.

        Returns:
        --------
        occupancies : pd.DataFrame.
            Contains the computed fractional occupancy
            of each PL state for each subject for the
            selected &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            occ = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/occupancies.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return occ

    def transitions(self,k=2):
        &#34;&#34;&#34;
        Return the computed transition probabilities between
        phase-locking states for a specific &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Specify the K-Means partition of interest.

        Returns:
        --------
        transitions : pd.DataFrame.
            Contains the computed transition probabilities
            between PL states for each subject for the selected
            &#39;k&#39; partition.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        try:
            tr = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)
        except:
            print(&#34;Can&#39;t find results for the selected k.&#34;)
        return tr
    
    def significant_states(self,metric=&#39;occupancies&#39;):
        &#34;&#34;&#34;
        Return a dataframe containing only the statistics
        of the phase-locking states that are significantly
        different between groups.

        Params:
        -------
        metric : str.
            Metric of interest (Options: &#39;occupancies&#39;,
            &#39;dwell_times&#39;).

        Returns:
        --------
        stats : pandas.dataframe.
        &#34;&#34;&#34;
        _check_metric(metric)

        try:
            stats = self._pool_stats(metric=metric)
        except:
            raise Exception(&#34;The stats could&#39;t be loaded.&#34;)
        has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
        if has_results:
            return stats[stats.reject_null==True]
        else:
            print(&#34;No significant results were detected.&#34;)
            return None
        
    def state_rois(self,k=2,state=1):
        &#34;&#34;&#34;
        Get a list with the names of the ROIs/parcels that
        participates in a specific phase-locking (PL) state.

        Params:
        -------
        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        Returns:
        --------
        rois : list.
            Contains the names of the ROIs that
            are part of the selected PL state.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
        data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
        rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
        return rois

    def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute the mean static functional
        connectivity matrix of a particular
        group/condition.

        Params:
        --------
        group : str.
            Specify the group of interest.

        plot : bool.
            Whether to create a heatmap showing
            the connectivity matrix.

        cmap : str.
            If plot=True, then select the colormap
            to use for the heatmap. Default = &#39;jet&#39;.

        darkstyle : bool.
            Whether to use a dark background
            for plotting.

        Returns:
        --------
        static_fc : ndarray with shape (N_ROIs, N_ROIs).
            The computed static functional connectivity
            matrix.
        &#34;&#34;&#34;
        if not isinstance(group,str):
            raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

        classes = load_classes(self._data_path_)

        #create list with conditions labels
        conditions = []
        for val in classes.values():
            for item in val:
                conditions.append(item)

        if len(conditions) != len(self.time_series().keys()):
            raise Exception(&#34;This method is only available in &#34;
                &#34;cases where each subject has only one condition label.&#34;)
        if group not in conditions:
            raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
                f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

        signals = load_tseries(self._data_path_)
        subjects_ids = [sub for sub,condition in zip(signals.keys(),conditions) if condition==group]
        N_subjects = len(subjects_ids)
        N_rois = len(self.rois_labels)
        pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
        
        for idx,sub in enumerate(subjects_ids):
            pooled_static_fc[:,:,idx] = np.corrcoef(signals[sub])
        
        static_fc = np.mean(pooled_static_fc,axis=-1)

        if plot:
            plt.ion()
            with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
                plt.figure()
                sns.heatmap(
                    static_fc,
                    vmin=-1,
                    vmax=1,
                    center=0,
                    square=True,
                    cmap=cmap,
                    cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
                )

                plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
                plt.title(group)
                plt.xticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist(),
                        rotation=0
                        )
                plt.yticks(
                        np.arange(20,N_rois,20),
                        np.arange(20,N_rois,20).tolist()
                        )
                plt.tick_params(
                    axis=&#39;both&#39;,         
                    which=&#39;both&#39;,     
                    bottom=False,
                    left=False
                    )
                plt.tight_layout()
                #plt.show()

        return static_fc

    def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Compute and plot the mean or median transition
        probabilities matrix of each group/condition.

        Params:
        -------
        k : int.
            The k-means partition of interest.

        metric : str.
            Whether to plot the &#39;mean&#39; or &#39;median&#39;
            matrices.

        cmap : str.
            Colormap to use in the created heatmaps.

        darkstyle : bool.
            Whether to use a dark background for
            plotting.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        data = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)

        mats = group_transition_matrix(
            data,
            metric=metric,
            cmap=cmap,
            darkstyle=darkstyle
            )

        return mats

    def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
        &#34;&#34;&#34;
        Compute the overlap between the 7 resting-state
        networks defined in Yeo et al. (2011) and the brain
        cortical regions/parcels of the phase-locking state
        of interest. The correlations are shown in a barplot,
        and a dataframe with the correlations and p-values is
        returned.

        Params:
        --------
        parcellation : str.
            Specify path to your parcellation .nii file.
            Note: the parcellation must be of 2mm resolution.

        n_areas : None | int.
            Analyze only the first n areas from the provided
            parcellation. 
            Usefull when the parcellation contains subcortical
            regions that must be ignored when computing the overlap
            with Yeo&#39;s cortical networks.

        k : int.
            Select the partition.

        state : int.
            Select the PL pattern or state of
            interest.

        darkstyle : bool.
            Whether to use a dark theme for the plot.

        Returns:
        --------
        overlap : pandas.dataframe with shape (7networks,3).
            Contains the correlation coefficient (and p-value)
            between the selected phase-locking state and each
            of the 7 resting-state networks from Yeo (2011).
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centr = {}

        for k_ in range(self._K_min_,self._K_max_+1):
            cent = self.load_centroids(k_)
            cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
            cent.insert(0,&#39;k&#39;,k_)
            centr[f&#39;k{k_}&#39;] = cent
        
        centr = pd.concat(centr,ignore_index=True)

        corr,pvals = rsnets.compute_overlap(
            centr,
            parcellation=parcellation,
            n_areas=n_areas
            )

        overlap = rsnets.state_overlap(
            corr,
            pvals,
            k=k,
            state=state,
            plot=True,
            darkstyle=darkstyle
            )

        return overlap

    def _pool_stats(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the stats for each k for the selected
        metric in a single dataframe.

        Params:
        --------
        metric : str.
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        data_path = self._dynamics_
        #get list with folder names
        k_folders = [folder for folder in os.listdir(data_path) 
                    if os.path.isdir(os.path.join(data_path,folder)) 
                    and folder.startswith(&#39;k_&#39;)]

        stats_all = []
        for folder in k_folders:
            stats_all.append(
                pd.read_csv(f&#39;{data_path}/{folder}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;)
                )
        stats_all = pd.concat((stats_all),ignore_index=True)

        stats_all = stats_all.sort_values(by=&#39;k&#39;).reset_index(drop=True)

        return stats_all

    def _pool_dynamics_metric(self,metric=&#34;occupancies&#34;):
        &#34;&#34;&#34;
        Pool the computed values for each k for the
        selected metric in a dictionary.

        Params:
        --------
        metric : str.
            Specify the metric of interest.
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).
        &#34;&#34;&#34;
        data_path = self._dynamics_
        #get list with folder names
        k_folders = [folder for folder in os.listdir(data_path)
                    if os.path.isdir(os.path.join(data_path,folder)) 
                    and folder.startswith(&#39;k_&#39;)]

        pooled_metric = {}
        for folder in k_folders:
            pooled_metric[folder] = pd.read_csv(f&#39;{data_path}/{folder}/{metric}.csv&#39;,sep=&#39;\t&#39;)

        return pooled_metric

    #plotting methods

    def plot_states_nodes(self,k=2,state=&#39;all&#39;,node_size=15,show_labels=True,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states in anatomical MNI space. Each parcel/ROI
        is represented as a node. Nodes that are part of
        the PL pattern are coloured in red, and the rest
        of nodes are coloured in blue.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size: int or float.
            Define the size of the nodes. Nodes
            that don&#39;t belong to the pattern are
            plotted smaller.

        show_labels : bool.
            Whether to show each ROI label.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates_ is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        centroids = self.load_centroids(k=k).values
        plots = brain_states_nodes(
            centroids,
            self.rois_coordinates_,
            node_size=node_size,
            state=state,
            nodes_labels=None if not show_labels else self.rois_labels,
            open=open
            )
        
        if save:
            _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

        return plots
    
    def plot_states_network(self,k=2,state=&#39;all&#39;,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states as a connected network. All the ROIs/parcels
        that belong to the selected phase-locking state are
        connected between each other.

        Params:
        -------
        k : int.
            Select the partition of interest.

        state : int or str.
            Use an integer to plot a single
            PL state of interest, or &#39;all&#39;
            to plot all the PL states of the
            selected K partition.

        node_size : int. 
            Select the size of the nodes.

        node_color : str. 
            Select the color of the nodes. If
            &#39;infer&#39;, then the nodes participating
            in the PL states are colored red and
            the rest blue. If &#39;black&#39;, then all the
            nodes are colored in the same way.

        linewidth : int. 
            Select the size of the edges
            connecting the nodes.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        plot/s : dict or single figure.
            If state=&#39;all&#39;, return a dictionary
            that contains the constructed plots.
            They can be opened or saved using
            &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
            respectively. If state=int, then return
            a single figure.
        &#34;&#34;&#34;
        if self.rois_coordinates_ is None:
            raise Exception(&#34;You can&#39;t create this plot because the &#34;
                            &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

        _check_k_input(self._K_min_,self._K_max_,k)
        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                            &#34;specifying the number of a particular PL state.&#34;)
        elif isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values #load centroids for the selected k

        #plotting
        plot = brain_states_network(
            centroids,
            self.rois_coordinates_,
            state=state,
            node_size=node_size,
            node_color=node_color,
            linewidth=linewidth,
            open=open
            )

        #saving figures
        if save:
            _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)

        return plot

    def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
        &#34;&#34;&#34;
        Create a pyramid of barplots showing the &#39;metric&#39;
        of interest for each group, cluster (PL state), and
        K partition. Each barplot (which represents a particular
        PL state) is coloured according to its associated p-value:
        -black: the p-value is higher than 0.05.
        -red: the p-value is lower than 0.05 but higher than 0.05 / k.
        -green: the p-value is lower than 0.05/k but higher than 0.05 / Σ(k).
        -blue: the p-value is lower than 0.05 / Σ(k).

        Params:
        -------
        metric : str.
            Select the dynamical systems theory metric
            of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

        conditions : None | list. Optional.
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        despine : bool. Default = True.
            Whether to despine top and right axes of the
            subplots.
        &#34;&#34;&#34;
        _check_metric(metric)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)
        K_min = np.min(pooled_stats.k)
        K_max = np.max(pooled_stats.k)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            dyn_metric = self._pool_dynamics_metric(metric=metric) 
            dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

            plot_pyramid(
                dyn_metric,
                pooled_stats_,
                K_min=K_min,
                K_max=K_max,
                despine=despine
                )

    def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
        &#34;&#34;&#34;
        Visualize the identified clusters (BOLD phase-locking
        states) in a 3D scatter plot, which constitutes a
        low-dimensional representation of the &#39;state space&#39;. 
        Method : take the eigenvectors and extract the first
        three principal components to reduce the dimensionality
        of the data to a 3D space. Each dot in the plot thus
        represents a single eigenvector, and is coloured according
        to the cluster it belongs to.
        
        Params:
        -------
        k : int.
            Specify the partition to plot.

        clusters_colors : list (optional). 
            Provide a list with the desired color
            of each cluster. If not provided, then
            a predefined set of colors will be used.

        grid : bool. 
            Whether to show grid or not.

        alpha : float. 
            Set transparency of dots.

        dot_size : float. 
            Select the dot size.

        edge_color : None | str.
            Specify an edge color to use
            on dots.

        darkstyle : bool.
            Whether to use a dark theme for
            the plot.
        &#34;&#34;&#34;
        X = self.eigenvectors.iloc[:,2:].values #keep array containing only the eigenvectors
        y = self.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plot_clusters3D(
                X,
                y,
                clusters_colors=clusters_colors,
                grid=grid,
                alpha=alpha,
                dot_size=dot_size,
                edgecolor=edgecolor
                )

    def barplot_centroids(self,k=2,state=&#39;all&#39;):
        &#34;&#34;&#34;
        Create either subplots with barplots showing the
        values of each cluster centroid for the selected &#39;k&#39;
        partition, or a single barplot showing the values
        of a specific phase-locking state.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : str or int.
            Specify if plot all the states for
            the selected &#39;k&#39;, or a single state
            of interest.
        &#34;&#34;&#34;
        centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
        if state==&#39;all&#39;:
            barplot_states(centroids,self.rois_labels)
        else:
            _check_state(k,state)
            barplot_eig(centroids[state-1,:],self.rois_labels)
            plt.title(f&#39;PL pattern {state}&#39;,fontsize=18)
            plt.tight_layout()

    def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
        &#34;&#34;&#34;
        Create a scatter plot showing the p-values
        obtained by the statistical analysis of a given
        &#39;metric&#39; across the explored &#39;k&#39; range.

        Params:
        -------
        metric : str. 
            Specify the metric of interest
            (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

        conditions : None | list. Optional
            (Usefull only when your data contains more
            than two conditions). You can provide a list
            specifying only two conditions of interest to
            plot. Otherwise create a plot for each pair of
            conditions. 

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.

        fill_areas : bool.
            Select whether to fill the significance
            areas with color.
        &#34;&#34;&#34;
        _check_metric(metric)

        if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

        if conditions is not None:
            if not isinstance(conditions,list) or len(conditions)!=2:
                raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
            for cond in conditions:
                if cond not in self._classes_lst_:
                    raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                    f&#34; Valid options are: {self._classes_lst_}&#34;)
        else:
            conditions = self._classes_lst_.copy()

        pooled_stats = self._pool_stats(metric=metric)

        for cond in combinations(conditions,2):
            pooled_stats_ = pooled_stats[
                    (pooled_stats.group_1.isin(cond))
                    &amp;
                    (pooled_stats.group_2.isin(cond))
                    ].reset_index(drop=True)

            scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)

    def plot_voronoi_cells(self,k=2):
        &#34;&#34;&#34;
        Plot the clusters centroids in a 2D Voronoi
        cells space. Performs a PCA to reduce the
        dimensionality of the original centroid space
        to a 2D space.

        Params:
        --------
        k : int.
            Select the clustering solution to plot.

        Note: see Vohryzek, Deco et al. (2020) p.4
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        centroids = self.load_centroids(k=k).values 
        plot_voronoi(centroids)

    def plot_clustering_performance(self):
        &#34;&#34;&#34;
        Create a 2x2 panel with lineplots showing
        the clustering evaluation metrics for each
        k partition explored (Dunn score, distortion,
        silhouette score, and Davis-Bouldin score).
        &#34;&#34;&#34;
        performance = pd.read_csv(f&#39;{self._clustering_}/clustering_performance.csv&#39;,sep=&#39;\t&#39;)
        plot_clustering_scores(performance)

    def plot_states_network_glass(self,k=2,darkstyle=False):
        &#34;&#34;&#34;
        Create a glass brain (axial view) showing the
        network representation of each phase-locking
        (PL) state for the selected &#39;k&#39; partition.

        Params:
        -------
        k : int.
            Select the partition of interest.

        darkstyle : bool.
            Whether to use a dark theme for
            the plots.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        pl_states = self.load_centroids(k=k).values

        with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
            states_k_glass(pl_states,self.rois_coordinates_,darkstyle=darkstyle)

    def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
        &#34;&#34;&#34;
        Create plot showing the time-series of BOLD signals, 
        highlighting the dominant phase-locking (PL) state
        of each time point or volume.

        Params:
        -------
        subject_id : str.
            Specify the &#39;id&#39; of the subject
            of interest.

        k : int.
            Select the k partition.

        alpha : float.
            Transparency of the colors that
            show the dominant PL pattern of
            each time point.

        darkstyle : bool.
            Whether to create the plot using
            a darkstyle.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        signals = load_tseries(self._data_path_)
        signals = signals[subject_id][:,1:-1] #get subject signals (and exclude 1st and last volumes)
        y = self.predictions[self.predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            states_in_bold(signals,y,alpha=alpha)

    def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
        &#34;&#34;&#34;
        Create a 3D interactive figure embedded in a
        .html file showing the BOLD phase-locking (PL)
        states on cortical surface. By default, all the
        cortical regions that belong to a given PL state
        or pattern are coloured in red(s), while the rest
        of cortical regions are coloured in blue(s). You
        can change the colormap throught the &#39;cmap&#39; argument.

        Params:
        -------
        k : int.
            Partition of interest.

        state : str or int.
            Whether to plot &#39;all&#39; the PL states of
            the selected partition or a single state
            of interest.

        parcellation : str.
            Path to the .nii file containing the
            parcellation from which the time series
            were extracted.

        discretize : bool. Default = True.
            Whether to plot the raw values of the
            phase-locking state/centroid, or plot
            all the brain regions that belong to
            the phase-locking state with the same
            intensity.

        cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
            Colormap to use in the brain plot.
            If &#39;auto&#39;, then the brain regions that
            belong to the phase-locking state will
            be coloured in red(s), and the rest of
            regions in blue(s).

        darkstyle : bool.
            Whether to use a black background.

        open : bool. 
            Whether to open the plots in web
            browser. If False, you can open the
            figures using the &#39;.open_in_browser()&#39;
            method of the returned object/s.

        save : bool.
            Whether to save each plot in a
            .html file. If True, the files
            are saved in &#39;LEiDA_results/brain_plots&#39;.

        Returns:
        --------
        g : SurfaceView or dictionarity of SurfaceViews. 
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(state,(int,str)):
            raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer specifying the number of a particular PL state&#34;)
        if isinstance(state,str):
            if state!=&#39;all&#39;:
                raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
        else:
            _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        if state!=&#39;all&#39;:
            centroids = centroids[state-1,:]
        
        g = brain_states_on_surf(
            centroids,
            parcellation=parcellation,
            black_bg=darkstyle,
            open=open,
            discretize=discretize,
            cmap=cmap
            )

        if save:
            _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

        return g

    def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
        &#34;&#34;&#34;
        Plot a BOLD phase-locking state of interest 
        on cortical surface mesh. 

        Params:
        -------
        k : int.
            Partition of interest.

        state : int.
            Select the PL state/pattern of
            interest.

        parcellation : str.
            Path to the .nii file containing
            the parcellation from which the
            signals were extracted.

        surface : str.
            Specify the surface type to plot
            the pattern on. Valid options are
            &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

        hemi : str.
            Select the hemisphere to plot.
            Valid options are &#39;right&#39;, &#39;left&#39;,
            or &#39;both&#39;.

        view : str
            View of the surface that is rendered. 
            Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
            &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
            &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
            and &#39;lateral&#39; views are displayed.

        darkstyle : bool
            Whether to use a black background.

        save : bool.
            Whether to save the created figure in
            local folder. If True, the files are
            saved in &#39;LEiDA_results/brain_plots&#39;,
            and the plot will not be displayed.

        Returns:
        --------
        g : matplotlib figure. 
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroids = self.load_centroids(k=k).values 
        centroid = centroids[state-1,:]

        #plotting
        print(&#34;\n-Creating plot. This may take &#34;
            &#34;some minutes. Please wait...&#34;)
            
        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            g = brain_states_on_surf2(
                centroid,
                parcellation=parcellation,
                hemi=hemi,
                surface=surface,
                view=view
                )
        
        if save:
            try:
                path = f&#39;{self._results_path_}/brain_plots&#39;
                if not os.path.exists(path): 
                    os.makedirs(path)
                filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}.png&#34;
                g.savefig(filename,dpi=300)
                plt.close()
                del g
                print(f&#34;The plot was save at: {filename}&#34;)
            except:
                raise Exception(&#34;An error occured when saving the plot.&#34;)
        else:
            return g

    def explore_state(self,k=2,state=1,darkstyle=False):
        &#34;&#34;&#34;
        Create a figure showing a phase-locking state of
        interest in different formats:
        a barplot, a network representation in brain space,
        a matrix representation, and two boxplots with the
        occupancies and dwell times for each group/condition.

        Params:
        ------
        k : int.
            Select the partition of interest.

        state : int.
            Select the PL state of interest.

        darkstyle : bool.
            Whether to use a dark background.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)
        _check_state(k,state)

        centroid = self.load_centroids(k=k).values
        centroid = centroid[state-1,:]

        occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
        dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            _explore_state(
                centroid,
                self.rois_labels,
                occ,
                dt,
                self.rois_coordinates_,
                state_number=state,
                darkstyle=darkstyle
                )

    def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
        &#34;&#34;&#34;
        Take the controids resulting from the k-means
        clustering (i.e., the phase-locking states) and
        reconstruct the connectivity patterns in matrix
        format.

        Params:
        -------
        k : int.
            Specify the K partition of interest.
        
        cmap : str. Default = &#39;jet&#39;.
            Select the colormap to use.

        darkstyle : bool.
            Whether to use a black background.
        &#34;&#34;&#34;
        _check_k_input(self._K_min_,self._K_max_,k)

        if not isinstance(cmap,str):
            raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
        if not isinstance(darkstyle,bool):
            raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

        _ = centroid2matrix(
            self.load_centroids(k).values,
            plot=True,
            cmap=cmap,
            darkstyle=darkstyle
            )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyleida._data_loader.DataLoader.barplot_centroids"><code class="name flex">
<span>def <span class="ident">barplot_centroids</span></span>(<span>self, k=2, state='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Create either subplots with barplots showing the
values of each cluster centroid for the selected 'k'
partition, or a single barplot showing the values
of a specific phase-locking state.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : str or int.
Specify if plot all the states for
the selected 'k', or a single state
of interest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barplot_centroids(self,k=2,state=&#39;all&#39;):
    &#34;&#34;&#34;
    Create either subplots with barplots showing the
    values of each cluster centroid for the selected &#39;k&#39;
    partition, or a single barplot showing the values
    of a specific phase-locking state.

    Params:
    ------
    k : int.
        Select the partition of interest.

    state : str or int.
        Specify if plot all the states for
        the selected &#39;k&#39;, or a single state
        of interest.
    &#34;&#34;&#34;
    centroids = np.array(self.load_centroids(k=k),dtype=np.float32) #get centroids of the selected &#39;k&#39;.
    if state==&#39;all&#39;:
        barplot_states(centroids,self.rois_labels)
    else:
        _check_state(k,state)
        barplot_eig(centroids[state-1,:],self.rois_labels)
        plt.title(f&#39;PL pattern {state}&#39;,fontsize=18)
        plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.centroids_distances"><code class="name flex">
<span>def <span class="ident">centroids_distances</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform eigenvectors to a cluster-distance space.
Returns the distance between each eigenvector and the
cluster centroids of the selected 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>distances : pd.DataFrame.
Contains the distace between each eigenvector and
each cluster centroid for the select 'k' partition.
1st column contains 'subject_id', 2nd column the
'condition', and the rest of columns the distances
to the centroids.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroids_distances(self,k=2):
    &#34;&#34;&#34;
    Transform eigenvectors to a cluster-distance space. 
    Returns the distance between each eigenvector and the
    cluster centroids of the selected &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    --------
    distances : pd.DataFrame.
        Contains the distace between each eigenvector and
        each cluster centroid for the select &#39;k&#39; partition.
        1st column contains &#39;subject_id&#39;, 2nd column the
        &#39;condition&#39;, and the rest of columns the distances
        to the centroids.
    &#34;&#34;&#34;
    model = self.load_model(k=k)
    distances = pd.DataFrame(model.transform(self.eigenvectors.iloc[:,2:].values))
    distances.columns = [f&#39;centroid_{centroid+1}&#39; for centroid in range(k)]
    distances = pd.concat((self.eigenvectors[[&#39;subject_id&#39;,&#39;condition&#39;]],distances),axis=1)
    return distances</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.dwell_times"><code class="name flex">
<span>def <span class="ident">dwell_times</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed dwell times of each
phase-locking state for a specific 'k'
partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>dwell_times : pd.DataFrame.
Contains the computed dwell times of each
PL state for each subject for the selected
'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dwell_times(self,k=2):
    &#34;&#34;&#34;
    Return the computed dwell times of each
    phase-locking state for a specific &#39;k&#39;
    partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of interest.

    Returns:
    --------
    dwell_times : pd.DataFrame.
        Contains the computed dwell times of each
        PL state for each subject for the selected
        &#39;k&#39; partition.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    try:
        dt = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/dwell_times.csv&#39;,sep=&#39;\t&#39;)
    except:
        print(&#34;Can&#39;t find results for the selected k.&#34;)
    return dt</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.explore_state"><code class="name flex">
<span>def <span class="ident">explore_state</span></span>(<span>self, k=2, state=1, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a figure showing a phase-locking state of
interest in different formats:
a barplot, a network representation in brain space,
a matrix representation, and two boxplots with the
occupancies and dwell times for each group/condition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int.
Select the PL state of interest.</p>
<p>darkstyle : bool.
Whether to use a dark background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explore_state(self,k=2,state=1,darkstyle=False):
    &#34;&#34;&#34;
    Create a figure showing a phase-locking state of
    interest in different formats:
    a barplot, a network representation in brain space,
    a matrix representation, and two boxplots with the
    occupancies and dwell times for each group/condition.

    Params:
    ------
    k : int.
        Select the partition of interest.

    state : int.
        Select the PL state of interest.

    darkstyle : bool.
        Whether to use a dark background.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centroid = self.load_centroids(k=k).values
    centroid = centroid[state-1,:]

    occ = self.occupancies(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]
    dt = self.dwell_times(k=k)[[&#39;condition&#39;,f&#39;PL_state_{state}&#39;]]

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        _explore_state(
            centroid,
            self.rois_labels,
            occ,
            dt,
            self.rois_coordinates_,
            state_number=state,
            darkstyle=darkstyle
            )</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.group_static_fc"><code class="name flex">
<span>def <span class="ident">group_static_fc</span></span>(<span>self, group=None, plot=True, cmap='jet', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean static functional
connectivity matrix of a particular
group/condition.</p>
<h2 id="params">Params:</h2>
<p>group : str.
Specify the group of interest.</p>
<p>plot : bool.
Whether to create a heatmap showing
the connectivity matrix.</p>
<p>cmap : str.
If plot=True, then select the colormap
to use for the heatmap. Default = 'jet'.</p>
<p>darkstyle : bool.
Whether to use a dark background
for plotting.</p>
<h2 id="returns">Returns:</h2>
<p>static_fc : ndarray with shape (N_ROIs, N_ROIs).
The computed static functional connectivity
matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_static_fc(self,group=None,plot=True,cmap=&#39;jet&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Compute the mean static functional
    connectivity matrix of a particular
    group/condition.

    Params:
    --------
    group : str.
        Specify the group of interest.

    plot : bool.
        Whether to create a heatmap showing
        the connectivity matrix.

    cmap : str.
        If plot=True, then select the colormap
        to use for the heatmap. Default = &#39;jet&#39;.

    darkstyle : bool.
        Whether to use a dark background
        for plotting.

    Returns:
    --------
    static_fc : ndarray with shape (N_ROIs, N_ROIs).
        The computed static functional connectivity
        matrix.
    &#34;&#34;&#34;
    if not isinstance(group,str):
        raise TypeError(&#34;&#39;group&#39; must be a string.&#34;)

    classes = load_classes(self._data_path_)

    #create list with conditions labels
    conditions = []
    for val in classes.values():
        for item in val:
            conditions.append(item)

    if len(conditions) != len(self.time_series().keys()):
        raise Exception(&#34;This method is only available in &#34;
            &#34;cases where each subject has only one condition label.&#34;)
    if group not in conditions:
        raise ValueError(&#34;&#39;group&#39; must be present in your data. &#34;
            f&#34;Possible options are: {[i for i in np.unique(conditions)]}.&#34;)       

    signals = load_tseries(self._data_path_)
    subjects_ids = [sub for sub,condition in zip(signals.keys(),conditions) if condition==group]
    N_subjects = len(subjects_ids)
    N_rois = len(self.rois_labels)
    pooled_static_fc = np.empty((N_rois,N_rois,N_subjects))
    
    for idx,sub in enumerate(subjects_ids):
        pooled_static_fc[:,:,idx] = np.corrcoef(signals[sub])
    
    static_fc = np.mean(pooled_static_fc,axis=-1)

    if plot:
        plt.ion()
        with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
            plt.figure()
            sns.heatmap(
                static_fc,
                vmin=-1,
                vmax=1,
                center=0,
                square=True,
                cmap=cmap,
                cbar_kws={&#39;label&#39;: &#39;Pearson\ncorrelation&#39;,&#39;shrink&#39;: 0.5}
            )

            plt.xlabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
            plt.ylabel(&#39;Brain region&#39;,fontsize=16,labelpad=20)
            plt.title(group)
            plt.xticks(
                    np.arange(20,N_rois,20),
                    np.arange(20,N_rois,20).tolist(),
                    rotation=0
                    )
            plt.yticks(
                    np.arange(20,N_rois,20),
                    np.arange(20,N_rois,20).tolist()
                    )
            plt.tick_params(
                axis=&#39;both&#39;,         
                which=&#39;both&#39;,     
                bottom=False,
                left=False
                )
            plt.tight_layout()
            #plt.show()

    return static_fc</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.group_transitions"><code class="name flex">
<span>def <span class="ident">group_transitions</span></span>(<span>self, k=2, metric='mean', cmap='inferno', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and plot the mean or median transition
probabilities matrix of each group/condition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
The k-means partition of interest.</p>
<p>metric : str.
Whether to plot the 'mean' or 'median'
matrices.</p>
<p>cmap : str.
Colormap to use in the created heatmaps.</p>
<p>darkstyle : bool.
Whether to use a dark background for
plotting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_transitions(self,k=2,metric=&#39;mean&#39;,cmap=&#39;inferno&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Compute and plot the mean or median transition
    probabilities matrix of each group/condition.

    Params:
    -------
    k : int.
        The k-means partition of interest.

    metric : str.
        Whether to plot the &#39;mean&#39; or &#39;median&#39;
        matrices.

    cmap : str.
        Colormap to use in the created heatmaps.

    darkstyle : bool.
        Whether to use a dark background for
        plotting.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)

    data = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)

    mats = group_transition_matrix(
        data,
        metric=metric,
        cmap=cmap,
        darkstyle=darkstyle
        )

    return mats</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.load_centroids"><code class="name flex">
<span>def <span class="ident">load_centroids</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed clusters centroids
for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>centroids : pd.DataFrame with shape (n_centroids,n_rois).
Contains the computed centroids for
the selected k partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_centroids(self,k=2):
    &#34;&#34;&#34;
    Return the computed clusters centroids
    for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    -------
    centroids : pd.DataFrame with shape (n_centroids,n_rois).
        Contains the computed centroids for
        the selected k partition.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    try:
        centroids = pd.DataFrame(self.load_model(k=k).cluster_centers_,columns=self.rois_labels)
    except:
        print(&#34;Can&#39;t find results for the selected k.&#34;)

    return centroids</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.load_model"><code class="name flex">
<span>def <span class="ident">load_model</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Load fitted model for a specific 'k' partition.
Given that each model is an instance of the KMeansLeida
class, once loaded you can access all the object methods
and attributes.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>model : KMeansLeida instance.
The fitted model that was used to predict
the cluster labels of each observation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_model(self,k=2):
    &#34;&#34;&#34;
    Load fitted model for a specific &#39;k&#39; partition.
    Given that each model is an instance of the KMeansLeida
    class, once loaded you can access all the object methods
    and attributes.

    Params:
    -------
    k : int.
        Select the partition of interest.
    
    Returns:
    -------
    model : KMeansLeida instance.
        The fitted model that was used to predict
        the cluster labels of each observation.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    try:
        model = pd.read_pickle(f&#39;{self._models_}/model_k_{k}.pkl&#39;)
        return model
    except:
        raise Exception(&#34;Can&#39;t find results for the selected k.&#34;)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.occupancies"><code class="name flex">
<span>def <span class="ident">occupancies</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed fractional occupancy of each
phase-locking state for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of
interest.</p>
<h2 id="returns">Returns:</h2>
<p>occupancies : pd.DataFrame.
Contains the computed fractional occupancy
of each PL state for each subject for the
selected 'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def occupancies(self,k=2):
    &#34;&#34;&#34;
    Return the computed fractional occupancy of each
    phase-locking state for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of
        interest.

    Returns:
    --------
    occupancies : pd.DataFrame.
        Contains the computed fractional occupancy
        of each PL state for each subject for the
        selected &#39;k&#39; partition.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    try:
        occ = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/occupancies.csv&#39;,sep=&#39;\t&#39;)
    except:
        print(&#34;Can&#39;t find results for the selected k.&#34;)
    return occ</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.overlap_withyeo"><code class="name flex">
<span>def <span class="ident">overlap_withyeo</span></span>(<span>self, parcellation=None, n_areas=None, k=2, state=None, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the overlap between the 7 resting-state
networks defined in Yeo et al. (2011) and the brain
cortical regions/parcels of the phase-locking state
of interest. The correlations are shown in a barplot,
and a dataframe with the correlations and p-values is
returned.</p>
<h2 id="params">Params:</h2>
<p>parcellation : str.
Specify path to your parcellation .nii file.
Note: the parcellation must be of 2mm resolution.</p>
<p>n_areas : None | int.
Analyze only the first n areas from the provided
parcellation.
Usefull when the parcellation contains subcortical
regions that must be ignored when computing the overlap
with Yeo's cortical networks.</p>
<p>k : int.
Select the partition.</p>
<p>state : int.
Select the PL pattern or state of
interest.</p>
<p>darkstyle : bool.
Whether to use a dark theme for the plot.</p>
<h2 id="returns">Returns:</h2>
<p>overlap : pandas.dataframe with shape (7networks,3).
Contains the correlation coefficient (and p-value)
between the selected phase-locking state and each
of the 7 resting-state networks from Yeo (2011).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlap_withyeo(self,parcellation=None,n_areas=None,k=2,state=None,darkstyle=False):
    &#34;&#34;&#34;
    Compute the overlap between the 7 resting-state
    networks defined in Yeo et al. (2011) and the brain
    cortical regions/parcels of the phase-locking state
    of interest. The correlations are shown in a barplot,
    and a dataframe with the correlations and p-values is
    returned.

    Params:
    --------
    parcellation : str.
        Specify path to your parcellation .nii file.
        Note: the parcellation must be of 2mm resolution.

    n_areas : None | int.
        Analyze only the first n areas from the provided
        parcellation. 
        Usefull when the parcellation contains subcortical
        regions that must be ignored when computing the overlap
        with Yeo&#39;s cortical networks.

    k : int.
        Select the partition.

    state : int.
        Select the PL pattern or state of
        interest.

    darkstyle : bool.
        Whether to use a dark theme for the plot.

    Returns:
    --------
    overlap : pandas.dataframe with shape (7networks,3).
        Contains the correlation coefficient (and p-value)
        between the selected phase-locking state and each
        of the 7 resting-state networks from Yeo (2011).
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centr = {}

    for k_ in range(self._K_min_,self._K_max_+1):
        cent = self.load_centroids(k_)
        cent.insert(0,&#39;state&#39;,[i+1 for i in range(cent.shape[0])])
        cent.insert(0,&#39;k&#39;,k_)
        centr[f&#39;k{k_}&#39;] = cent
    
    centr = pd.concat(centr,ignore_index=True)

    corr,pvals = rsnets.compute_overlap(
        centr,
        parcellation=parcellation,
        n_areas=n_areas
        )

    overlap = rsnets.state_overlap(
        corr,
        pvals,
        k=k,
        state=state,
        plot=True,
        darkstyle=darkstyle
        )

    return overlap</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_clustering_performance"><code class="name flex">
<span>def <span class="ident">plot_clustering_performance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 2x2 panel with lineplots showing
the clustering evaluation metrics for each
k partition explored (Dunn score, distortion,
silhouette score, and Davis-Bouldin score).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clustering_performance(self):
    &#34;&#34;&#34;
    Create a 2x2 panel with lineplots showing
    the clustering evaluation metrics for each
    k partition explored (Dunn score, distortion,
    silhouette score, and Davis-Bouldin score).
    &#34;&#34;&#34;
    performance = pd.read_csv(f&#39;{self._clustering_}/clustering_performance.csv&#39;,sep=&#39;\t&#39;)
    plot_clustering_scores(performance)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_clusters3D"><code class="name flex">
<span>def <span class="ident">plot_clusters3D</span></span>(<span>self, k=2, clusters_colors=None, grid=True, alpha=0.7, dot_size=3, edgecolor=None, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize the identified clusters (BOLD phase-locking
states) in a 3D scatter plot, which constitutes a
low-dimensional representation of the 'state space'.
Method : take the eigenvectors and extract the first
three principal components to reduce the dimensionality
of the data to a 3D space. Each dot in the plot thus
represents a single eigenvector, and is coloured according
to the cluster it belongs to.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the partition to plot.</p>
<p>clusters_colors : list (optional).
Provide a list with the desired color
of each cluster. If not provided, then
a predefined set of colors will be used.</p>
<p>grid : bool.
Whether to show grid or not.</p>
<p>alpha : float.
Set transparency of dots.</p>
<p>dot_size : float.
Select the dot size.</p>
<p>edge_color : None | str.
Specify an edge color to use
on dots.</p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters3D(self,k=2,clusters_colors=None,grid=True,alpha=.7,dot_size=3,edgecolor=None,darkstyle=False):
    &#34;&#34;&#34;
    Visualize the identified clusters (BOLD phase-locking
    states) in a 3D scatter plot, which constitutes a
    low-dimensional representation of the &#39;state space&#39;. 
    Method : take the eigenvectors and extract the first
    three principal components to reduce the dimensionality
    of the data to a 3D space. Each dot in the plot thus
    represents a single eigenvector, and is coloured according
    to the cluster it belongs to.
    
    Params:
    -------
    k : int.
        Specify the partition to plot.

    clusters_colors : list (optional). 
        Provide a list with the desired color
        of each cluster. If not provided, then
        a predefined set of colors will be used.

    grid : bool. 
        Whether to show grid or not.

    alpha : float. 
        Set transparency of dots.

    dot_size : float. 
        Select the dot size.

    edge_color : None | str.
        Specify an edge color to use
        on dots.

    darkstyle : bool.
        Whether to use a dark theme for
        the plot.
    &#34;&#34;&#34;
    X = self.eigenvectors.iloc[:,2:].values #keep array containing only the eigenvectors
    y = self.predictions[f&#39;k_{k}&#39;].values #keep 1D array with the labels of each eigenvector

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        plot_clusters3D(
            X,
            y,
            clusters_colors=clusters_colors,
            grid=grid,
            alpha=alpha,
            dot_size=dot_size,
            edgecolor=edgecolor
            )</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_pvalues"><code class="name flex">
<span>def <span class="ident">plot_pvalues</span></span>(<span>self, metric='occupancies', conditions=None, darkstyle=False, fill_areas=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a scatter plot showing the p-values
obtained by the statistical analysis of a given
'metric' across the explored 'k' range.</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Specify the metric of interest
('occupancies','dwell_times','transitions').</p>
<p>conditions : None | list. Optional
(Usefull only when your data contains more
than two conditions). You can provide a list
specifying only two conditions of interest to
plot. Otherwise create a plot for each pair of
conditions. </p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plots.</p>
<p>fill_areas : bool.
Select whether to fill the significance
areas with color.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pvalues(self,metric=&#39;occupancies&#39;,conditions=None,darkstyle=False,fill_areas=True):
    &#34;&#34;&#34;
    Create a scatter plot showing the p-values
    obtained by the statistical analysis of a given
    &#39;metric&#39; across the explored &#39;k&#39; range.

    Params:
    -------
    metric : str. 
        Specify the metric of interest
        (&#39;occupancies&#39;,&#39;dwell_times&#39;,&#39;transitions&#39;).

    conditions : None | list. Optional
        (Usefull only when your data contains more
        than two conditions). You can provide a list
        specifying only two conditions of interest to
        plot. Otherwise create a plot for each pair of
        conditions. 

    darkstyle : bool.
        Whether to use a dark theme for
        the plots.

    fill_areas : bool.
        Select whether to fill the significance
        areas with color.
    &#34;&#34;&#34;
    _check_metric(metric)

    if not isinstance(fill_areas,bool) or not isinstance(darkstyle,bool):
        raise TypeError(&#34;&#39;fill_areas&#39; and &#39;darkstyle&#39; must be True or False!&#34;)

    if conditions is not None:
        if not isinstance(conditions,list) or len(conditions)!=2:
            raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
        for cond in conditions:
            if cond not in self._classes_lst_:
                raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                f&#34; Valid options are: {self._classes_lst_}&#34;)
    else:
        conditions = self._classes_lst_.copy()

    pooled_stats = self._pool_stats(metric=metric)

    for cond in combinations(conditions,2):
        pooled_stats_ = pooled_stats[
                (pooled_stats.group_1.isin(cond))
                &amp;
                (pooled_stats.group_2.isin(cond))
                ].reset_index(drop=True)

        scatter_pvalues(pooled_stats_,metric=metric,darkstyle=darkstyle,fill_areas=fill_areas)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_in_bold"><code class="name flex">
<span>def <span class="ident">plot_states_in_bold</span></span>(<span>self, subject_id, k=2, alpha=0.5, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create plot showing the time-series of BOLD signals,
highlighting the dominant phase-locking (PL) state
of each time point or volume.</p>
<h2 id="params">Params:</h2>
<p>subject_id : str.
Specify the 'id' of the subject
of interest.</p>
<p>k : int.
Select the k partition.</p>
<p>alpha : float.
Transparency of the colors that
show the dominant PL pattern of
each time point.</p>
<p>darkstyle : bool.
Whether to create the plot using
a darkstyle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_in_bold(self,subject_id,k=2,alpha=.5,darkstyle=False):
    &#34;&#34;&#34;
    Create plot showing the time-series of BOLD signals, 
    highlighting the dominant phase-locking (PL) state
    of each time point or volume.

    Params:
    -------
    subject_id : str.
        Specify the &#39;id&#39; of the subject
        of interest.

    k : int.
        Select the k partition.

    alpha : float.
        Transparency of the colors that
        show the dominant PL pattern of
        each time point.

    darkstyle : bool.
        Whether to create the plot using
        a darkstyle.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    signals = load_tseries(self._data_path_)
    signals = signals[subject_id][:,1:-1] #get subject signals (and exclude 1st and last volumes)
    y = self.predictions[self.predictions.subject_id==subject_id][f&#39;k_{k}&#39;].values #get predictions for selected k.

    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        states_in_bold(signals,y,alpha=alpha)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_matrices"><code class="name flex">
<span>def <span class="ident">plot_states_matrices</span></span>(<span>self, k=2, cmap='jet', darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the controids resulting from the k-means
clustering (i.e., the phase-locking states) and
reconstruct the connectivity patterns in matrix
format.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K partition of interest.</p>
<p>cmap : str. Default = 'jet'.
Select the colormap to use.</p>
<p>darkstyle : bool.
Whether to use a black background.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_matrices(self,k=2,cmap=&#39;jet&#39;,darkstyle=False):
    &#34;&#34;&#34;
    Take the controids resulting from the k-means
    clustering (i.e., the phase-locking states) and
    reconstruct the connectivity patterns in matrix
    format.

    Params:
    -------
    k : int.
        Specify the K partition of interest.
    
    cmap : str. Default = &#39;jet&#39;.
        Select the colormap to use.

    darkstyle : bool.
        Whether to use a black background.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)

    if not isinstance(cmap,str):
        raise TypeError(&#34;&#39;cmap&#39; must be a string!&#34;)
    if not isinstance(darkstyle,bool):
        raise TypeError(&#34;&#39;darkstyle&#39; must be True or False!&#34;)

    _ = centroid2matrix(
        self.load_centroids(k).values,
        plot=True,
        cmap=cmap,
        darkstyle=darkstyle
        )</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_network"><code class="name flex">
<span>def <span class="ident">plot_states_network</span></span>(<span>self, k=2, state='all', node_size=8, node_color='infer', linewidth=3, open=True, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states as a connected network. All the ROIs/parcels
that belong to the selected phase-locking state are
connected between each other.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int or str.
Use an integer to plot a single
PL state of interest, or 'all'
to plot all the PL states of the
selected K partition.</p>
<p>node_size : int.
Select the size of the nodes.</p>
<p>node_color : str.
Select the color of the nodes. If
'infer', then the nodes participating
in the PL states are colored red and
the rest blue. If 'black', then all the
nodes are colored in the same way.</p>
<p>linewidth : int.
Select the size of the edges
connecting the nodes.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>plot/s : dict or single figure.
If state='all', return a dictionary
that contains the constructed plots.
They can be opened or saved using
'.open()' and '.save_as_html(path)',
respectively. If state=int, then return
a single figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_network(self,k=2,state=&#39;all&#39;,node_size=8,node_color=&#39;infer&#39;,linewidth=3,open=True,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states as a connected network. All the ROIs/parcels
    that belong to the selected phase-locking state are
    connected between each other.

    Params:
    -------
    k : int.
        Select the partition of interest.

    state : int or str.
        Use an integer to plot a single
        PL state of interest, or &#39;all&#39;
        to plot all the PL states of the
        selected K partition.

    node_size : int. 
        Select the size of the nodes.

    node_color : str. 
        Select the color of the nodes. If
        &#39;infer&#39;, then the nodes participating
        in the PL states are colored red and
        the rest blue. If &#39;black&#39;, then all the
        nodes are colored in the same way.

    linewidth : int. 
        Select the size of the edges
        connecting the nodes.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    plot/s : dict or single figure.
        If state=&#39;all&#39;, return a dictionary
        that contains the constructed plots.
        They can be opened or saved using
        &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
        respectively. If state=int, then return
        a single figure.
    &#34;&#34;&#34;
    if self.rois_coordinates_ is None:
        raise Exception(&#34;You can&#39;t create this plot because the &#34;
                        &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

    _check_k_input(self._K_min_,self._K_max_,k)
    if not isinstance(state,(int,str)):
        raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer &#34;
                        &#34;specifying the number of a particular PL state.&#34;)
    elif isinstance(state,str):
        if state!=&#39;all&#39;:
            raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
    else:
        _check_state(k,state)

    centroids = self.load_centroids(k=k).values #load centroids for the selected k

    #plotting
    plot = brain_states_network(
        centroids,
        self.rois_coordinates_,
        state=state,
        node_size=node_size,
        node_color=node_color,
        linewidth=linewidth,
        open=open
        )

    #saving figures
    if save:
        _save_html(self._results_path_,plot,k,state,plot_type=&#39;network&#39;)

    return plot</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_network_glass"><code class="name flex">
<span>def <span class="ident">plot_states_network_glass</span></span>(<span>self, k=2, darkstyle=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a glass brain (axial view) showing the
network representation of each phase-locking
(PL) state for the selected 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>darkstyle : bool.
Whether to use a dark theme for
the plots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_network_glass(self,k=2,darkstyle=False):
    &#34;&#34;&#34;
    Create a glass brain (axial view) showing the
    network representation of each phase-locking
    (PL) state for the selected &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the partition of interest.

    darkstyle : bool.
        Whether to use a dark theme for
        the plots.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    pl_states = self.load_centroids(k=k).values

    with plt.style.context(&#34;dark_background&#34; if darkstyle else &#34;default&#34;):
        states_k_glass(pl_states,self.rois_coordinates_,darkstyle=darkstyle)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_nodes"><code class="name flex">
<span>def <span class="ident">plot_states_nodes</span></span>(<span>self, k=2, state='all', node_size=15, show_labels=True, open=True, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states in anatomical MNI space. Each parcel/ROI
is represented as a node. Nodes that are part of
the PL pattern are coloured in red, and the rest
of nodes are coloured in blue.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition of interest.</p>
<p>state : int or str.
Use an integer to plot a single
PL state of interest, or 'all'
to plot all the PL states of the
selected K partition.</p>
<p>node_size: int or float.
Define the size of the nodes. Nodes
that don't belong to the pattern are
plotted smaller.</p>
<p>show_labels : bool.
Whether to show each ROI label.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>plot/s : dict or single figure.
If state='all', return a dictionary
that contains the constructed plots.
They can be opened or saved using
'.open()' and '.save_as_html(path)',
respectively. If state=int, then return
a single figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_nodes(self,k=2,state=&#39;all&#39;,node_size=15,show_labels=True,open=True,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states in anatomical MNI space. Each parcel/ROI
    is represented as a node. Nodes that are part of
    the PL pattern are coloured in red, and the rest
    of nodes are coloured in blue.

    Params:
    -------
    k : int.
        Select the partition of interest.

    state : int or str.
        Use an integer to plot a single
        PL state of interest, or &#39;all&#39;
        to plot all the PL states of the
        selected K partition.

    node_size: int or float.
        Define the size of the nodes. Nodes
        that don&#39;t belong to the pattern are
        plotted smaller.

    show_labels : bool.
        Whether to show each ROI label.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    plot/s : dict or single figure.
        If state=&#39;all&#39;, return a dictionary
        that contains the constructed plots.
        They can be opened or saved using
        &#39;.open()&#39; and &#39;.save_as_html(path)&#39;,
        respectively. If state=int, then return
        a single figure.
    &#34;&#34;&#34;
    if self.rois_coordinates_ is None:
        raise Exception(&#34;You can&#39;t create this plot because the &#34;
                        &#34;ROI&#39;s coordinates could&#39;t be loaded.&#34;)

    centroids = self.load_centroids(k=k).values
    plots = brain_states_nodes(
        centroids,
        self.rois_coordinates_,
        node_size=node_size,
        state=state,
        nodes_labels=None if not show_labels else self.rois_labels,
        open=open
        )
    
    if save:
        _save_html(self._results_path_,plots,k,state,plot_type=&#39;nodes&#39;)

    return plots</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_on_surf"><code class="name flex">
<span>def <span class="ident">plot_states_on_surf</span></span>(<span>self, k=2, state='all', parcellation=None, discretize=True, cmap='auto', darkstyle=False, open=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D interactive figure embedded in a
.html file showing the BOLD phase-locking (PL)
states on cortical surface. By default, all the
cortical regions that belong to a given PL state
or pattern are coloured in red(s), while the rest
of cortical regions are coloured in blue(s). You
can change the colormap throught the 'cmap' argument.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Partition of interest.</p>
<p>state : str or int.
Whether to plot 'all' the PL states of
the selected partition or a single state
of interest.</p>
<p>parcellation : str.
Path to the .nii file containing the
parcellation from which the time series
were extracted.</p>
<p>discretize : bool. Default = True.
Whether to plot the raw values of the
phase-locking state/centroid, or plot
all the brain regions that belong to
the phase-locking state with the same
intensity.</p>
<p>cmap : str or matplotlib colormap, optional. Default = 'auto'.
Colormap to use in the brain plot.
If 'auto', then the brain regions that
belong to the phase-locking state will
be coloured in red(s), and the rest of
regions in blue(s).</p>
<p>darkstyle : bool.
Whether to use a black background.</p>
<p>open : bool.
Whether to open the plots in web
browser. If False, you can open the
figures using the '.open_in_browser()'
method of the returned object/s.</p>
<p>save : bool.
Whether to save each plot in a
.html file. If True, the files
are saved in 'LEiDA_results/brain_plots'.</p>
<h2 id="returns">Returns:</h2>
<p>g : SurfaceView or dictionarity of SurfaceViews.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_on_surf(self,k=2,state=&#39;all&#39;,parcellation=None,discretize=True,cmap=&#39;auto&#39;,darkstyle=False,open=False,save=False):
    &#34;&#34;&#34;
    Create a 3D interactive figure embedded in a
    .html file showing the BOLD phase-locking (PL)
    states on cortical surface. By default, all the
    cortical regions that belong to a given PL state
    or pattern are coloured in red(s), while the rest
    of cortical regions are coloured in blue(s). You
    can change the colormap throught the &#39;cmap&#39; argument.

    Params:
    -------
    k : int.
        Partition of interest.

    state : str or int.
        Whether to plot &#39;all&#39; the PL states of
        the selected partition or a single state
        of interest.

    parcellation : str.
        Path to the .nii file containing the
        parcellation from which the time series
        were extracted.

    discretize : bool. Default = True.
        Whether to plot the raw values of the
        phase-locking state/centroid, or plot
        all the brain regions that belong to
        the phase-locking state with the same
        intensity.

    cmap : str or matplotlib colormap, optional. Default = &#39;auto&#39;.
        Colormap to use in the brain plot.
        If &#39;auto&#39;, then the brain regions that
        belong to the phase-locking state will
        be coloured in red(s), and the rest of
        regions in blue(s).

    darkstyle : bool.
        Whether to use a black background.

    open : bool. 
        Whether to open the plots in web
        browser. If False, you can open the
        figures using the &#39;.open_in_browser()&#39;
        method of the returned object/s.

    save : bool.
        Whether to save each plot in a
        .html file. If True, the files
        are saved in &#39;LEiDA_results/brain_plots&#39;.

    Returns:
    --------
    g : SurfaceView or dictionarity of SurfaceViews. 
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)

    if not isinstance(state,(int,str)):
        raise TypeError(&#34;&#39;state&#39; must be either &#39;all&#39; or an integer specifying the number of a particular PL state&#34;)
    if isinstance(state,str):
        if state!=&#39;all&#39;:
            raise ValueError(&#34;If a string is provided, &#39;state&#39; must be &#39;all&#39;!&#34;)
    else:
        _check_state(k,state)

    centroids = self.load_centroids(k=k).values 
    if state!=&#39;all&#39;:
        centroids = centroids[state-1,:]
    
    g = brain_states_on_surf(
        centroids,
        parcellation=parcellation,
        black_bg=darkstyle,
        open=open,
        discretize=discretize,
        cmap=cmap
        )

    if save:
        _save_html(self._results_path_,g,k,state,plot_type=&#39;surface&#39;)

    return g</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_on_surf2"><code class="name flex">
<span>def <span class="ident">plot_states_on_surf2</span></span>(<span>self, k=2, state=1, parcellation=None, surface='pial', hemi='right', view='lateral', darkstyle=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a BOLD phase-locking state of interest
on cortical surface mesh. </p>
<h2 id="params">Params:</h2>
<p>k : int.
Partition of interest.</p>
<p>state : int.
Select the PL state/pattern of
interest.</p>
<p>parcellation : str.
Path to the .nii file containing
the parcellation from which the
signals were extracted.</p>
<p>surface : str.
Specify the surface type to plot
the pattern on. Valid options are
'pial','infl', and 'white'.</p>
<p>hemi : str.
Select the hemisphere to plot.
Valid options are 'right', 'left',
or 'both'.</p>
<p>view : str
View of the surface that is rendered.
Default='lateral'. Options = {'lateral',
'medial', 'dorsal', 'ventral', 'anterior',
'posterior'}. If 'hemi'='both', then 'dorsal'
and 'lateral' views are displayed.</p>
<p>darkstyle : bool
Whether to use a black background.</p>
<p>save : bool.
Whether to save the created figure in
local folder. If True, the files are
saved in 'LEiDA_results/brain_plots',
and the plot will not be displayed.</p>
<h2 id="returns">Returns:</h2>
<p>g : matplotlib figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_on_surf2(self,k=2,state=1,parcellation=None,surface=&#39;pial&#39;,hemi=&#39;right&#39;,view=&#39;lateral&#39;,darkstyle=False,save=False):
    &#34;&#34;&#34;
    Plot a BOLD phase-locking state of interest 
    on cortical surface mesh. 

    Params:
    -------
    k : int.
        Partition of interest.

    state : int.
        Select the PL state/pattern of
        interest.

    parcellation : str.
        Path to the .nii file containing
        the parcellation from which the
        signals were extracted.

    surface : str.
        Specify the surface type to plot
        the pattern on. Valid options are
        &#39;pial&#39;,&#39;infl&#39;, and &#39;white&#39;.

    hemi : str.
        Select the hemisphere to plot.
        Valid options are &#39;right&#39;, &#39;left&#39;,
        or &#39;both&#39;.

    view : str
        View of the surface that is rendered. 
        Default=&#39;lateral&#39;. Options = {&#39;lateral&#39;,
        &#39;medial&#39;, &#39;dorsal&#39;, &#39;ventral&#39;, &#39;anterior&#39;,
        &#39;posterior&#39;}. If &#39;hemi&#39;=&#39;both&#39;, then &#39;dorsal&#39;
        and &#39;lateral&#39; views are displayed.

    darkstyle : bool
        Whether to use a black background.

    save : bool.
        Whether to save the created figure in
        local folder. If True, the files are
        saved in &#39;LEiDA_results/brain_plots&#39;,
        and the plot will not be displayed.

    Returns:
    --------
    g : matplotlib figure. 
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    centroids = self.load_centroids(k=k).values 
    centroid = centroids[state-1,:]

    #plotting
    print(&#34;\n-Creating plot. This may take &#34;
        &#34;some minutes. Please wait...&#34;)
        
    with plt.style.context(&#39;dark_background&#39; if darkstyle else &#39;default&#39;):
        g = brain_states_on_surf2(
            centroid,
            parcellation=parcellation,
            hemi=hemi,
            surface=surface,
            view=view
            )
    
    if save:
        try:
            path = f&#39;{self._results_path_}/brain_plots&#39;
            if not os.path.exists(path): 
                os.makedirs(path)
            filename = f&#34;{path}/K{k}_PL_state_{state}_{surface}surf_{hemi}hemi_{view if hemi!=&#39;both&#39; else &#39;multiview&#39;}.png&#34;
            g.savefig(filename,dpi=300)
            plt.close()
            del g
            print(f&#34;The plot was save at: {filename}&#34;)
        except:
            raise Exception(&#34;An error occured when saving the plot.&#34;)
    else:
        return g</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_states_pyramid"><code class="name flex">
<span>def <span class="ident">plot_states_pyramid</span></span>(<span>self, metric='occupancies', conditions=None, despine=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a pyramid of barplots showing the 'metric'
of interest for each group, cluster (PL state), and
K partition. Each barplot (which represents a particular
PL state) is coloured according to its associated p-value:
-black: the p-value is higher than 0.05.
-red: the p-value is lower than 0.05 but higher than 0.05 / k.
-green: the p-value is lower than 0.05/k but higher than 0.05 / Σ(k).
-blue: the p-value is lower than 0.05 / Σ(k).</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Select the dynamical systems theory metric
of interest (either 'occupancies' or 'dwell_times').</p>
<p>conditions : None | list. Optional.
(Usefull only when your data contains more
than two conditions). You can provide a list
specifying only two conditions of interest to
plot. Otherwise create a plot for each pair of
conditions. </p>
<p>despine : bool. Default = True.
Whether to despine top and right axes of the
subplots.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_states_pyramid(self,metric=&#39;occupancies&#39;,conditions=None,despine=True):
    &#34;&#34;&#34;
    Create a pyramid of barplots showing the &#39;metric&#39;
    of interest for each group, cluster (PL state), and
    K partition. Each barplot (which represents a particular
    PL state) is coloured according to its associated p-value:
    -black: the p-value is higher than 0.05.
    -red: the p-value is lower than 0.05 but higher than 0.05 / k.
    -green: the p-value is lower than 0.05/k but higher than 0.05 / Σ(k).
    -blue: the p-value is lower than 0.05 / Σ(k).

    Params:
    -------
    metric : str.
        Select the dynamical systems theory metric
        of interest (either &#39;occupancies&#39; or &#39;dwell_times&#39;).

    conditions : None | list. Optional.
        (Usefull only when your data contains more
        than two conditions). You can provide a list
        specifying only two conditions of interest to
        plot. Otherwise create a plot for each pair of
        conditions. 

    despine : bool. Default = True.
        Whether to despine top and right axes of the
        subplots.
    &#34;&#34;&#34;
    _check_metric(metric)

    if conditions is not None:
        if not isinstance(conditions,list) or len(conditions)!=2:
            raise Exception(&#34;If provided, &#39;conditions&#39; must be a list with two items.&#34;)
        for cond in conditions:
            if cond not in self._classes_lst_:
                raise Exception(f&#34;&#39;{cond}&#39; was not founded in the data. &#34;
                                f&#34; Valid options are: {self._classes_lst_}&#34;)
    else:
        conditions = self._classes_lst_.copy()

    pooled_stats = self._pool_stats(metric=metric)
    K_min = np.min(pooled_stats.k)
    K_max = np.max(pooled_stats.k)

    for cond in combinations(conditions,2):
        pooled_stats_ = pooled_stats[
                (pooled_stats.group_1.isin(cond))
                &amp;
                (pooled_stats.group_2.isin(cond))
                ].reset_index(drop=True)

        dyn_metric = self._pool_dynamics_metric(metric=metric) 
        dyn_metric = {k:v[v.condition.isin(conditions)] for k,v in dyn_metric.items()}

        plot_pyramid(
            dyn_metric,
            pooled_stats_,
            K_min=K_min,
            K_max=K_max,
            despine=despine
            )</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.plot_voronoi_cells"><code class="name flex">
<span>def <span class="ident">plot_voronoi_cells</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the clusters centroids in a 2D Voronoi
cells space. Performs a PCA to reduce the
dimensionality of the original centroid space
to a 2D space.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the clustering solution to plot.</p>
<p>Note: see Vohryzek, Deco et al. (2020) p.4</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_voronoi_cells(self,k=2):
    &#34;&#34;&#34;
    Plot the clusters centroids in a 2D Voronoi
    cells space. Performs a PCA to reduce the
    dimensionality of the original centroid space
    to a 2D space.

    Params:
    --------
    k : int.
        Select the clustering solution to plot.

    Note: see Vohryzek, Deco et al. (2020) p.4
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    centroids = self.load_centroids(k=k).values 
    plot_voronoi(centroids)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.significant_states"><code class="name flex">
<span>def <span class="ident">significant_states</span></span>(<span>self, metric='occupancies')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dataframe containing only the statistics
of the phase-locking states that are significantly
different between groups.</p>
<h2 id="params">Params:</h2>
<p>metric : str.
Metric of interest (Options: 'occupancies',
'dwell_times').</p>
<h2 id="returns">Returns:</h2>
<p>stats : pandas.dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def significant_states(self,metric=&#39;occupancies&#39;):
    &#34;&#34;&#34;
    Return a dataframe containing only the statistics
    of the phase-locking states that are significantly
    different between groups.

    Params:
    -------
    metric : str.
        Metric of interest (Options: &#39;occupancies&#39;,
        &#39;dwell_times&#39;).

    Returns:
    --------
    stats : pandas.dataframe.
    &#34;&#34;&#34;
    _check_metric(metric)

    try:
        stats = self._pool_stats(metric=metric)
    except:
        raise Exception(&#34;The stats could&#39;t be loaded.&#34;)
    has_results = True if stats[stats.reject_null==True].shape[0]&gt;=1 else False #check if some result was significant
    if has_results:
        return stats[stats.reject_null==True]
    else:
        print(&#34;No significant results were detected.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.state_rois"><code class="name flex">
<span>def <span class="ident">state_rois</span></span>(<span>self, k=2, state=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list with the names of the ROIs/parcels that
participates in a specific phase-locking (PL) state.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the partition.</p>
<p>state : int.
Select the PL pattern or state of
interest.</p>
<h2 id="returns">Returns:</h2>
<p>rois : list.
Contains the names of the ROIs that
are part of the selected PL state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def state_rois(self,k=2,state=1):
    &#34;&#34;&#34;
    Get a list with the names of the ROIs/parcels that
    participates in a specific phase-locking (PL) state.

    Params:
    -------
    k : int.
        Select the partition.

    state : int.
        Select the PL pattern or state of
        interest.

    Returns:
    --------
    rois : list.
        Contains the names of the ROIs that
        are part of the selected PL state.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_state(k,state)

    data_k = self.load_centroids(k=k).iloc[state-1,:].reset_index()
    data_k.columns = [&#39;rois&#39;,&#39;value&#39;]
    rois = list(data_k[data_k.value&gt;0][&#39;rois&#39;])
    return rois</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self, k=2, metric='occupancies')</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the results from the statistical analysis of
a 'metric' of interest ('occupancies' or 'dwell_times')
for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Select the 'k' partition of interest.</p>
<p>metric : str.
Select the metric to retrieve results.</p>
<h2 id="returns">Returns:</h2>
<p>stats : pandas.dataframe.
Results of the statistical analysis
of each PL state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self,k=2,metric=&#39;occupancies&#39;):
    &#34;&#34;&#34;
    Retrieve the results from the statistical analysis of 
    a &#39;metric&#39; of interest (&#39;occupancies&#39; or &#39;dwell_times&#39;)
    for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Select the &#39;k&#39; partition of interest.

    metric : str.
        Select the metric to retrieve results.

    Returns:
    --------
    stats : pandas.dataframe.
        Results of the statistical analysis
        of each PL state.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    _check_metric(metric)

    try:
        df_stats = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/{metric}_stats.csv&#39;,sep=&#39;\t&#39;)
    except:
        print(&#34;Can&#39;t find results for the selected k or metric.&#34;)
    return df_stats</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.time_series"><code class="name flex">
<span>def <span class="ident">time_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary having the 'subject_ids'
as keys, and 2D arrays (N_ROIs,N_volumes) with
BOLD time series as values.</p>
<h2 id="returns">Returns:</h2>
<p>time_series : dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_series(self):
    &#34;&#34;&#34;
    Return a dictionary having the &#39;subject_ids&#39;
    as keys, and 2D arrays (N_ROIs,N_volumes) with
    BOLD time series as values.

    Returns:
    --------
    time_series : dict.
    &#34;&#34;&#34;
    return load_tseries(self._data_path_)</code></pre>
</details>
</dd>
<dt id="pyleida._data_loader.DataLoader.transitions"><code class="name flex">
<span>def <span class="ident">transitions</span></span>(<span>self, k=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the computed transition probabilities between
phase-locking states for a specific 'k' partition.</p>
<h2 id="params">Params:</h2>
<p>k : int.
Specify the K-Means partition of interest.</p>
<h2 id="returns">Returns:</h2>
<p>transitions : pd.DataFrame.
Contains the computed transition probabilities
between PL states for each subject for the selected
'k' partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transitions(self,k=2):
    &#34;&#34;&#34;
    Return the computed transition probabilities between
    phase-locking states for a specific &#39;k&#39; partition.

    Params:
    -------
    k : int.
        Specify the K-Means partition of interest.

    Returns:
    --------
    transitions : pd.DataFrame.
        Contains the computed transition probabilities
        between PL states for each subject for the selected
        &#39;k&#39; partition.
    &#34;&#34;&#34;
    _check_k_input(self._K_min_,self._K_max_,k)
    try:
        tr = pd.read_csv(f&#39;{self._dynamics_}/k_{k}/transitions_probabilities.csv&#39;,sep=&#39;\t&#39;)
    except:
        print(&#34;Can&#39;t find results for the selected k.&#34;)
    return tr</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
    <a href="https://sites.google.com/view/psychomark/home">
        <img src="imgs/psychomark_logo.png" alt="logo" width="150" height="100"/>
    </a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyleida" href="index.html">pyleida</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Methods</a></h3>
<ul>
<li>
<h4><code><a title="pyleida._data_loader.DataLoader" href="#pyleida._data_loader.DataLoader">DataLoader</a></code></h4>
<ul class="">
<li><code><a title="pyleida._data_loader.DataLoader.barplot_centroids" href="#pyleida._data_loader.DataLoader.barplot_centroids">barplot_centroids</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.centroids_distances" href="#pyleida._data_loader.DataLoader.centroids_distances">centroids_distances</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.dwell_times" href="#pyleida._data_loader.DataLoader.dwell_times">dwell_times</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.explore_state" href="#pyleida._data_loader.DataLoader.explore_state">explore_state</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.group_static_fc" href="#pyleida._data_loader.DataLoader.group_static_fc">group_static_fc</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.group_transitions" href="#pyleida._data_loader.DataLoader.group_transitions">group_transitions</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.load_centroids" href="#pyleida._data_loader.DataLoader.load_centroids">load_centroids</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.load_model" href="#pyleida._data_loader.DataLoader.load_model">load_model</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.occupancies" href="#pyleida._data_loader.DataLoader.occupancies">occupancies</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.overlap_withyeo" href="#pyleida._data_loader.DataLoader.overlap_withyeo">overlap_withyeo</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_clustering_performance" href="#pyleida._data_loader.DataLoader.plot_clustering_performance">plot_clustering_performance</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_clusters3D" href="#pyleida._data_loader.DataLoader.plot_clusters3D">plot_clusters3D</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_pvalues" href="#pyleida._data_loader.DataLoader.plot_pvalues">plot_pvalues</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_in_bold" href="#pyleida._data_loader.DataLoader.plot_states_in_bold">plot_states_in_bold</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_matrices" href="#pyleida._data_loader.DataLoader.plot_states_matrices">plot_states_matrices</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_network" href="#pyleida._data_loader.DataLoader.plot_states_network">plot_states_network</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_network_glass" href="#pyleida._data_loader.DataLoader.plot_states_network_glass">plot_states_network_glass</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_nodes" href="#pyleida._data_loader.DataLoader.plot_states_nodes">plot_states_nodes</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_on_surf" href="#pyleida._data_loader.DataLoader.plot_states_on_surf">plot_states_on_surf</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_on_surf2" href="#pyleida._data_loader.DataLoader.plot_states_on_surf2">plot_states_on_surf2</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_states_pyramid" href="#pyleida._data_loader.DataLoader.plot_states_pyramid">plot_states_pyramid</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.plot_voronoi_cells" href="#pyleida._data_loader.DataLoader.plot_voronoi_cells">plot_voronoi_cells</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.significant_states" href="#pyleida._data_loader.DataLoader.significant_states">significant_states</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.state_rois" href="#pyleida._data_loader.DataLoader.state_rois">state_rois</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.stats" href="#pyleida._data_loader.DataLoader.stats">stats</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.time_series" href="#pyleida._data_loader.DataLoader.time_series">time_series</a></code></li>
<li><code><a title="pyleida._data_loader.DataLoader.transitions" href="#pyleida._data_loader.DataLoader.transitions">transitions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>